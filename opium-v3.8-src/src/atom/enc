hysolve.F:c it under the terms of the GNU General Public License as published by
hysolve.F:c the Free Software Foundation; either version 2 of the License, or
hysolve.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
hysolve.F:c GNU General Public License for more details.
hysolve.F:c You should have received a copy of the GNU General Public License
hysolve.F:c     determine the self-consistent solution
hysolve.F:c     External (shared between C and Fortran) common blocks
hysolve.F:      common /filenames/ file_log
hysolve.F:      common /box/ iboxstart(n0),iboxend(n0),boxheight(n0),numbox
hysolve.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hysolve.F:      dimension rvn(npdm),rvf(npdm),eold(n0),p(npdm)
hysolve.F:      dimension rsatom(npdm),f(npdm),f2(npdm),f3(npdm)
hysolve.F:      dimension pder(npdm),ader(npdm)
hysolve.F:      dimension dl(n0), rsatom2(npdm)
hysolve.F:      dimension rsold(npdm),wnlfract(npdm)
hysolve.F:      dimension wavea(npdm),icarray(n0)
hysolve.F:      open(unit=7,file=file_log,form='formatted',access='append')
hysolve.F:c     User supplied eigenvalue guesses were never used in the SRL
hysolve.F:      if (irel.eq.1) then
hysolve.F:            en(i)=-z*z/(no(i)*no(i))
hysolve.F:         enddo
hysolve.F:            if (ibd(i).ne.0) en(ii)=-z*z/(no(ii)*no(ii))
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:c      if (ipsp.eq.1) then
hysolve.F:c            write(7,*) i,en(i),no(i),lo(i),so(i),ibd(i)
hysolve.F:c         enddo
hysolve.F:c      endif
hysolve.F:      write(7,*) '---------Eigenvalue guesses---------'      
hysolve.F:         write(7,9339) no(i),xc(lo(i)),en(i)
hysolve.F:      enddo
hysolve.F:      if (ipsp.eq.1) then
hysolve.F:      endif
hysolve.F:      if (inl.ne.0) then
hysolve.F:            enddo
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:      if (ifc.eq.0) then
hysolve.F:            eold(j) = en(j)
hysolve.F:            if (irel.eq.0) then
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            endif               
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:      if (inl.ne.0) then
hysolve.F:          enddo
hysolve.F:        enddo
hysolve.F:      endif
hysolve.F:      enddo
hysolve.F:      !open(unit=7,file=file_log,form='formatted',access='append')
hysolve.F:      iflag=0  ! comment by JY: this is a dummy variable 
hysolve.F:c     EJW - adding this to keep allow to pick a hyrdogenic wavefunction 
hysolve.F:      enddo
hysolve.F:         en(i)=-en(i)
hysolve.F:         enddo
hysolve.F:         e(i,i)=en(i)
hysolve.F:         enddo
hysolve.F:      enddo
hysolve.F:      if (ipsp.eq.0) then
hysolve.F:            enddo
hysolve.F:            e(j,j)=-en(j)
hysolve.F:            enddo
hysolve.F:         enddo
hysolve.F:            enddo
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:      enddo
hysolve.F:      enddo
hysolve.F:      if (ipsp.eq.0) then
hysolve.F:            enddo
hysolve.F:         enddo
hysolve.F:            if (lcount(lo(i)+1).gt.1) then
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:            if (e(i,j).gt.0.d0) then
hysolve.F:               if (abs(rx).gt.1e-8) then
hysolve.F:                  enddo
hysolve.F:               endif
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      enddo
hysolve.F:      !end initialization of HF
hysolve.F:      if (inl.ne.0) then
hysolve.F:        write(7,*)"Performing non-local pseudopotential calculation"
hysolve.F:         if (ipsp.ne.0) then
hysolve.F:       write(7,*) "Performing semi-local pseudopotential calculation"
hysolve.F:         endif
hysolve.F:      endif
hysolve.F:      if (ipsp.eq.1.and.inl.ne.0) then
hysolve.F:      endif
hysolve.F: 9600 format(1x,'Using the ',a1,' potential as the local potential')
hysolve.F:      if (ipsp.eq.1.and.inl.ne.0.and.numbox.gt.0) then
hysolve.F:         enddo
hysolve.F:            write(7,9240) i,r(iboxstart(i)),r(iboxend(i)),boxheight(i) 
hysolve.F:            if (r(iboxend(i)).gt.rindmin) ioutmin = 1
hysolve.F:            if (r(iboxend(i)).gt.rindmax) ioutmax = 1
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F: 9220 format(1x,'--Augmentation operator info--')
hysolve.F: 9250 format(1x,'NOTE: One or more functions extend beyond the',
hysolve.F: 9260 format(1x,'WARNING!: One or more functions extend beyond the',
hysolve.F:c     Begin self-consistency loop.
hysolve.F:         if (niter.eq.1) then
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:         enddo
hysolve.F:c     Section 3:  call schsl for each orbital & compile charge density.
hysolve.F:         if(ixc.ge.0. .and. ixc.lt.7) then
hysolve.F:            if (m.le.ncore) then
hysolve.F:            endif
hysolve.F:            if (ifc.eq.0.or.m.gt.ncore) then
hysolve.F:c     if not a frozen core calc or if valence
hysolve.F:               if (irel.eq.0) then
hysolve.F:                  if (inl.ne.0) then
hysolve.F:                     enddo
hysolve.F:                     call schsl (m,no(m),lo(m),en(m),nmax(m),
hysolve.F:                     enddo
hysolve.F:                     call schsl(m,no(m),lo(m),en(m),nmax(m),
hysolve.F:                  endif
hysolve.F:                  enddo
hysolve.F:                  enddo                  
hysolve.F:                  edif = abs((en(m) - eold(m))/eold(m))
hysolve.F:                  eold(m) = en(m)
hysolve.F:     $                 rnlb(1,m),z,rvcoul,en,nmax(m),ibound)
hysolve.F:                  enddo
hysolve.F:                  enddo                  
hysolve.F:                  edif = abs((en(m) - eold(m))/eold(m))
hysolve.F:                  eold(m) = en(m)
hysolve.F:               endif
hysolve.F:c     if not a frozen core calc or if valence 
hysolve.F:            endif
hysolve.F:          enddo
hysolve.F:          endif
hysolve.F:          !LZT: end application of kohn-sham operator
hysolve.F:          if(ixc.lt.0 .or. ixc.eq.7) then
hysolve.F:            write (7,*) "Hybrid functionals will be implemented soon!"
hysolve.F:          endif
hysolve.F:          if (ixc.eq.7) then 
hysolve.F:          endif
hysolve.F:         if(maxim.eq.0) then
hysolve.F:         endif
hysolve.F:c     Section 4:  mix density
hysolve.F:         if (niter.gt.3) then
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:c     Section 5:  update self-consistent potentials and compute energy.
hysolve.F:         if (rpcc.gt.1e-12.and.ipsp.ne.0) then
hysolve.F:            enddo
hysolve.F:            enddo
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:            ebs = ebs + wnl(m) * en(m)
hysolve.F:         enddo
hysolve.F:c     Section 6:  Mix potentials
hysolve.F:         enddo
hysolve.F:         enddo
hysolve.F:            enddo
hysolve.F:         enddo
hysolve.F:         if (niter.eq.1) then
hysolve.F:         endif
hysolve.F:c     Section 7:  predict trial eigenvals use 1st order perturb theory.
hysolve.F:         enddo
hysolve.F:            if (m.le.ncore) then
hysolve.F:            endif
hysolve.F:            if (ifc.eq.0.and.ibound.eq.1) then
hysolve.F:               if (irel.eq.0) then
hysolve.F:                  enddo
hysolve.F:                  enddo
hysolve.F:               endif
hysolve.F:               if(nmax(m).le.10) then
hysolve.F:               endif
hysolve.F:               en(m) = en(m) + xl
hysolve.F:               if (en(m).ge.0.0) then
hysolve.F:                  enddo
hysolve.F:                  en(m) = vmin * 0.5d0
hysolve.F:                  write (7,505) nlm(m),en(m)               
hysolve.F:                  if (en(m).ne.en(m)) then
hysolve.F:                  endif
hysolve.F:               endif
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      enddo !self-consistency loop ends here
hysolve.F: 505  format(1x,'!WARNING! positive eigenvalue predicted',
hysolve.F:      if (ilogder.eq.1) then
hysolve.F:         if (ipsp.eq.0) then
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:         if (ipsp.eq.1) then
hysolve.F:            if (inl.eq.0) then
hysolve.F:                  enddo
hysolve.F:                  enddo
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         endif
hysolve.F:      endif
hysolve.F:         if (irel.eq.0) then
hysolve.F:               if (abs(rnl(k,i)).gt.1e-10) then
hysolve.F:                  if (rnl(k,i).lt.0.0) then
hysolve.F:                     enddo
hysolve.F:                  endif
hysolve.F:               endif
hysolve.F:            enddo
hysolve.F:c            if (ibd(i-ncore).eq.0) then
hysolve.F:c               enddo
hysolve.F:c            endif
hysolve.F:               if (abs(rnla(k,i)).gt.1e-10) then
hysolve.F:                  if (rnla(k,i).lt.0.0) then
hysolve.F:                     enddo
hysolve.F:                  endif
hysolve.F:               endif
hysolve.F:            enddo
hysolve.F:               if (abs(rnlb(k,i)).gt.1e-10) then
hysolve.F:                  if (rnlb(k,i).lt.0.0) then
hysolve.F:                     enddo
hysolve.F:                  endif
hysolve.F:               endif
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:      enddo
hysolve.F:c     compute valence density 
hysolve.F:      enddo
hysolve.F:         if (irel.eq.0) then
hysolve.F:            enddo
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:      enddo
hysolve.F:c     compute core density
hysolve.F:      if (ipsp.eq.0) then
hysolve.F:         enddo
hysolve.F:            if (irel.eq.0) then
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:c     loop over valence
hysolve.F:      if (irel.eq.0) then
hysolve.F:            enddo
hysolve.F:            if (ibd(ic).eq.1) then
hysolve.F:c     special treatment for unbound states (norm from 0 to rc is 1)
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo                     
hysolve.F:            enddo
hysolve.F:            if (ibd(ic).eq.1) then
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:c      if (ipsp.eq.0) then
hysolve.F:c            enddo
hysolve.F:c         enddo
hysolve.F:c      endif
hysolve.F:c        if (rnla(maxim,i).lt.0.0) then
hysolve.F:c          enddo
hysolve.F:c        endif
hysolve.F:c      enddo
hysolve.F:      if (irel.eq.0) then
hysolve.F:            if (ibd(ic).ne.0) then
hysolve.F:                  if (rnl(j,i).lt.rnl(j+1,i)) then
hysolve.F:                  endif
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:            if (ibd(i-ncore).ne.0) then
hysolve.F:                  if (rnla(j,i).lt.rnla(j+1,i)) then
hysolve.F:     $                    and.(abs(rnla(j,i)).gt.1e-6)) then
hysolve.F:                     endif
hysolve.F:                  endif
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:      if (niter.eq.1) then
hysolve.F:      endif
hysolve.F:         if (irel.eq.0) then
hysolve.F:            write (7,9223) nlm(i),wnl(i),en(i)
hysolve.F:            if (lo(i).eq.0) then
hysolve.F:               write (7,9523) nlm(i),wnl(i),en(i)
hysolve.F:               if (so(i).lt.0) then
hysolve.F:                  write (7,9323) nlm(i),wnl(i),en(i)
hysolve.F:                  write (7,9423) nlm(i),wnl(i),en(i)
hysolve.F:               endif
hysolve.F:            endif
hysolve.F:         endif
hysolve.F:      enddo
hysolve.F:         if (irel.eq.0) then
hysolve.F:            if (ibd(ic).ne.0) then
hysolve.F:               write (7,9223) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
hysolve.F:               write (7,9224) nlm(i),wnl(i),en(i)
hysolve.F:            endif
hysolve.F:            if (lo(i).eq.0) then
hysolve.F:               if (ibd(ic).ne.0) then
hysolve.F:                  write (7,9523) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
hysolve.F:                  write (7,9524) nlm(i),wnl(i),en(i)
hysolve.F:               endif
hysolve.F:               if (so(i).lt.0) then
hysolve.F:                  if (ibd(ic).ne.0) then
hysolve.F:                     write (7,9323) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
hysolve.F:                     write (7,9324) nlm(i),wnl(i),en(i)
hysolve.F:                  endif
hysolve.F:                  if (ibd(ic).ne.0) then
hysolve.F:                     write (7,9423) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
hysolve.F:                     write (7,9424) nlm(i),wnl(i),en(i)
hysolve.F:                  endif
hysolve.F:               endif
hysolve.F:            endif
hysolve.F:         endif
hysolve.F:      enddo
hysolve.F:      if (ipsp.ne.0.and.rpcc.gt.1e-12) then
hysolve.F:      endif
hysolve.F: 700  format(1x,'Converged in 1 iteration (probably reference state)')
hysolve.F: 9222 format(3x,'Orbital',4x,'Filling',7x,'Eigenvalues',4x,
hysolve.F:      if (inl.ne.0) then
hysolve.F:      endif
hysolve.F:      write(7,*) " !!ERROR!! Could not find self-consistent solution!"
hysolve.F:     +     ' number of valence orbitals =',i3,/,
hysolve.F:      end
intdir.F:c it under the terms of the GNU General Public License as published by
intdir.F:c the Free Software Foundation; either version 2 of the License, or
intdir.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
intdir.F:c GNU General Public License for more details.
intdir.F:c You should have received a copy of the GNU General Public License
intdir.F:      subroutine intdir(gg,gp,ag,ap,ggmat,gpmat,en,dv,av,
intdir.F:c            solution of the inhomogenios dirac equation                        
intdir.F:c ag and ap development coefficients of  gg and gp                              
intdir.F:c en one-electron energy                                                        
intdir.F:c fl power of the first development term at the origin                          
intdir.F:c agi (api) initial values of the first development coefficients                
intdir.F:c at the origin of a large (small) component                                    
intdir.F:c ainf initial value for large component at point dr(max0)                      
intdir.F:c   - at the end of tabulation of gg gp                                         
intdir.F:      dimension gg(npdm),gp(npdm),ag(10),ap(10),
intdir.F:      dimension dv(npdm)
intdir.F:      if (icall.eq.0) then                                                      
intdir.F:      endif                                                                     
intdir.F:      ec=en/cl                                                                  
intdir.F:c      enddo
intdir.F:      if (mat.ge.imax) then    
intdir.F:c     i had trouble with screened k-hole for la, for f-electrons.                 
intdir.F:c     below i still define matching point if one electron energy is               
intdir.F:         if (ec .gt. -0.0003) then                                           
intdir.F:         endif                                                               
intdir.F:      endif   
intdir.F:c     integration of the inhomogenious system                                   
intdir.F:         if ((imax+1).le.(mat+npi)) then                                        
intdir.F:         endif                                                                  
intdir.F:c      write(7,*) 'end test1', test1
intdir.F:      end                                                                       
interp2.F:c it under the terms of the GNU General Public License as published by
interp2.F:c the Free Software Foundation; either version 2 of the License, or
interp2.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
interp2.F:c GNU General Public License for more details.
interp2.F:c You should have received a copy of the GNU General Public License
interp2.F:      dimension f(npdm),f2(npdm),fp(npdm),f3(npdm)
interp2.F:      enddo
interp2.F:      end
interp2.F:c     Given arrays x(1:n) and y(1:n) containing a tabulated function,
interp2.F:c     i.e., yi = f(xi), with x1 < x2 < .. . < xN, and given values yp1
interp2.F:c     y2(1:n) of length n which contains the second derivatives of the
interp2.F:      if (yp1.gt..99e30) then 
interp2.F:      endif
interp2.F:      enddo 
interp2.F:      if (ypn.gt..99e30) then 
interp2.F:      endif
interp2.F:      enddo 
interp2.F: 1    if (khi-klo.gt.1) then
interp2.F:         if (xa(k).gt.x)then
interp2.F:         endif
interp2.F:      endif 
lagdat.F:c it under the terms of the GNU General Public License as published by
lagdat.F:c the Free Software Foundation; either version 2 of the License, or
lagdat.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
lagdat.F:c GNU General Public License for more details.
lagdat.F:c You should have received a copy of the GNU General Public License
lagdat.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
lagdat.F:      dimension kap(n0)
lagdat.F:      dimension ni(2),nj(2)                                                     
lagdat.F:      end                                                                       
logder.F:c it under the terms of the GNU General Public License as published by
logder.F:c the Free Software Foundation; either version 2 of the License, or
logder.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
logder.F:c GNU General Public License for more details.
logder.F:c You should have received a copy of the GNU General Public License
logder.F:      subroutine logder(en,z,l,isoft,rv,g,r,np,h,rlog,dl,nnt1,nr,p,
logder.F:      dimension rv(npdm),r(npdm),dl(n0),p(npdm),dld(npdm),g(npdm)
logder.F:      dimension w(4),wi(4)
logder.F:c     ensure nr is multiple of 2 integer and nr >= 4
logder.F:c     ensure that rlog is within range of grid
logder.F:      if(rlog.ge.r(np-nrh-1)) then
logder.F:      endif
logder.F:      e = en
logder.F:   94 e = en + float(ie-3)*de
logder.F:c       addition of inhomogeneous term g(i)
logder.F:c       local potential was taken as x*r**-1 + y + w*r
logder.F:c       non-local potential was taken as g1*r**(l+2.5)+g2*r**(l+3.5)+
logder.F:c     a = 1 (assumption of wavefunction leading term coefficient for
logder.F:c            inhomogeneous solution only)
logder.F:      enddo
logder.F:      if(ncross.ge.0) then
logder.F:      endif
logder.F:      enddo
logder.F:      enddo
logder.F:c     end of changes made by njr
logder.F:      enddo
logder.F:      if(ie.eq.3) then
logder.F:        enddo
logder.F:      endif
logder.F:      enddo
logder.F:c     energy derivative evaluated by 5-pt symmetric interpolation
logder.F:      end
nllogd.F:c it under the terms of the GNU General Public License as published by
nllogd.F:c the Free Software Foundation; either version 2 of the License, or
nllogd.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
nllogd.F:c GNU General Public License for more details.
nllogd.F:c You should have received a copy of the GNU General Public License
nllogd.F:c     External (shared between C and Fortran) common blocks
nllogd.F:      common /box/ iboxstart(n0),iboxend(n0),boxheight(n0),numbox
nllogd.F:      dimension rvloc(npdm),g(npdm)
nllogd.F:      dimension ader(npdm),phomder(npdm),pinhomdr(npdm),Flphider(npdm)
nllogd.F:      dimension Flwder(npdm),Flxder(npdm),pder(npdm)
nllogd.F:      dimension dl(n0)
nllogd.F:      enddo
nllogd.F:      enddo
nllogd.F:      if (ilogder.eq.1) then
nllogd.F:         if (rphas.gt.rcall(istate)) then
nllogd.F:            enddo
nllogd.F:               enddo
nllogd.F:               if (abs(flinvder).le.1e-10) then
nllogd.F:               endif
nllogd.F:               if (inl.eq.0) then wtilder = 0
nllogd.F:               enddo
nllogd.F:            enddo
nllogd.F:         endif
nllogd.F:      endif
nllogd.F:      end
nllogd.F:c     External (shared between C and Fortran) common blocks
nllogd.F:      common /box/ iboxstart(n0),iboxend(n0),boxheight(n0),numbox
nllogd.F:      dimension rvl(npdm),rvs(npdm)
nllogd.F:c      IB     = iboxend(1)
nllogd.F:c      ID     = iboxend(2)
nllogd.F:c      IG     = iboxend(3)
nllogd.F:c      IJ     = iboxend(4)
nllogd.F:      enddo
nllogd.F:c      enddo
nllogd.F:c      enddo
nllogd.F:c      enddo
nllogd.F:c      enddo
nllogd.F:c     Replacement for the blocks commented out above; allows for more
nllogd.F:         do j = iboxstart(i),iboxend(i)
nllogd.F:         enddo
nllogd.F:      enddo
nllogd.F:      end
norm.F:c it under the terms of the GNU General Public License as published by
norm.F:c the Free Software Foundation; either version 2 of the License, or
norm.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
norm.F:c GNU General Public License for more details.
norm.F:c You should have received a copy of the GNU General Public License
norm.F:      dimension hp(npdm),dr(npdm),gg(npdm),
norm.F:      end                                                                       
ortdat.F:c it under the terms of the GNU General Public License as published by
ortdat.F:c the Free Software Foundation; either version 2 of the License, or
ortdat.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
ortdat.F:c GNU General Public License for more details.
ortdat.F:c You should have received a copy of the GNU General Public License
ortdat.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
ortdat.F:      dimension kap(n0)
ortdat.F:      end                                                                       
pbe.F:C  pw91 CORRELATION, modified by K. Burke to put all arguments 
pbe.F:c  as variables in calling statement, rather than in common block
pbe.F:c inputs: up=up density
pbe.F:c       : lpot=flag to do potential(=0=>don't)
pbe.F:c outputs: exlsd=LSD exchange energy density, so that
pbe.F:c        : vxuplsd=up LSD exchange potential
pbe.F:c        : vxdnlsd=down LSD exchange potential
pbe.F:c        : exclsd=LSD exchange-correlation energy density
pbe.F:c        : vxcuplsd=up LSD exchange-correlation potential
pbe.F:c        : vxcdnlsd=down LSD exchange-correlation potential
pbe.F:c s=dimensionless density gradient=|grad rho|/ (2*fk*rho)_(rho=2*up)
pbe.F:      if(rho2.gt.1d-18)then
pbe.F:      endif
pbe.F:      if(rho2.gt.1d-18)then
pbe.F:      endif
pbe.F:c construct total density and contribution to ex
pbe.F:c sk=Ks=Thomas-Fermi screening wavevector=sqrt(4fk/pi)
pbe.F:c t=correlation dimensionless gradient=|grad rho|/(2*Ks*phi*rho)
pbe.F:c ec=lsd correlation energy
pbe.F:c vcup=lsd up correlation potential
pbe.F:c vcdn=lsd down correlation potential
pbe.F:c h=gradient correction to correlation energy
pbe.F:c dvcup=gradient correction to up correlation potential
pbe.F:c dvcdn=gradient correction to down correlation potential
pbe.F:      end
pbe.F:c  input lgga:  (=0=>don't put in gradient corrections, just LDA)
pbe.F:c  input lpot:  (=0=>don't get potential and don't need U and V)
pbe.F:c References:
pbe.F:c construct LDA exchange energy density
pbe.F:      if(lgga.eq.0)then
pbe.F:      endif
pbe.F:c construct PBE enhancement factor
pbe.F:c calculate potential from [b](24) 
pbe.F:c  input lgga:  (=0=>don't put in gradient corrections, just LDA)
pbe.F:c  input lpot:  (=0=>don't get potential and don't need U and V)
pbe.F:c References:
pbe.F:c construct LDA exchange energy density
pbe.F:      if(lgga.eq.0)then
pbe.F:      endif
pbe.F:c construct PBE enhancement factor
pbe.F:c calculate potential from [b](24) 
pbe.F:c       :  UU,VV,WW, only needed for PBE potential
pbe.F:c       : lpot=flag to do potential (0=>energy only)
pbe.F:c  output: ec=lsd correlation energy from [a]
pbe.F:c        : vcup=lsd up correlation potential
pbe.F:c        : vcdn=lsd dn correlation potential
pbe.F:c References:
pbe.F:c     {\sl Generalized gradient approximation made simple}, sub.
pbe.F:c     construction of a generalized gradient approximation:  The PW91
pbe.F:c     density functional}, submitted to Phys. Rev. B, Feb. 1996.
pbe.F:c numbers for use in LSD energy spin-interpolation formula, [c](9).
pbe.F:c      bet=coefficient in gradient expansion for correlation, [a](4).
pbe.F:c find LSD energy contributions, using [c](10) and Table I[c].
pbe.F:c EU=unpolarized LSD correlation energy
pbe.F:c EP=fully polarized LSD correlation energy
pbe.F:c LSD potential from [c](A1)
pbe.F:c PBE correlation energy
pbe.F:c G=phi(zeta), given after [a](3)
pbe.F:C ENERGY DONE. NOW THE POTENTIAL, using appendix E of [b].
pbe.F:c       :  UU,VV,WW, only needed for PBE potential
pbe.F:c       : lpot=flag to do potential (0=>energy only)
pbe.F:c  output: ec=lsd correlation energy from [a]
pbe.F:c        : vcup=lsd up correlation potential
pbe.F:c        : vcdn=lsd dn correlation potential
pbe.F:c References:
pbe.F:c     {\sl Generalized gradient approximation made simple}, sub.
pbe.F:c     construction of a generalized gradient approximation:  The PW91
pbe.F:c     density functional}, submitted to Phys. Rev. B, Feb. 1996.
pbe.F:c numbers for use in LSD energy spin-interpolation formula, [c](9).
pbe.F:c      bet=coefficient in gradient expansion for correlation, [a](4).
pbe.F:c find LSD energy contributions, using [c](10) and Table I[c].
pbe.F:c EU=unpolarized LSD correlation energy
pbe.F:c EP=fully polarized LSD correlation energy
pbe.F:c LSD potential from [c](A1)
pbe.F:c PBE correlation energy
pbe.F:c G=phi(zeta), given after [a](3)
pbe.F:C ENERGY DONE. NOW THE POTENTIAL, using appendix E of [b].
pbe.F:c LSD correlation energy, as given by (10) of
pbe.F:c    This piece delivers all of the Wu-Cohen functional ingredients
pbe.F:c  input lgga:  (=0=>don't put in gradient corrections, just LDA)
pbe.F:c  input lpot:  (=0=>don't get potential and don't need U and V)
pbe.F:c References:
pbe.F:c construct LDA exchange energy density
pbe.F:      if(lgga.eq.0)then
pbe.F:      endif
pbe.F:c construct PBE enhancement factor
pbe.F:c calculate potential from [b](24) 
potl.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
potl.F:c it under the terms of the GNU General Public License as published by
potl.F:c the Free Software Foundation; either version 2 of the License, or
potl.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
potl.F:c GNU General Public License for more details.
potl.F:c You should have received a copy of the GNU General Public License
potl.F:c     get the hartree potential function
potl.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
potl.F:      dimension yk(npdm),yr(npdm)
potl.F:      enddo
potl.F:            if (dabs(aaa(i,j,k)) .ge. 1.d-8) then
potl.F:               enddo
potl.F:            endif
potl.F:         enddo
potl.F:      enddo
potl.F:      end
potrdf.F:c it under the terms of the GNU General Public License as published by
potrdf.F:c the Free Software Foundation; either version 2 of the License, or
potrdf.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
potrdf.F:c GNU General Public License for more details.
potrdf.F:c You should have received a copy of the GNU General Public License
potrdf.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
potrdf.F:      dimension bgj(10),bpj(10),rjunk(npdm)                                                 
potrdf.F:      dimension at(npdm),bt(npdm),kap(n0)
potrdf.F:      dimension rvs(npdm),rvn(npdm),anoy(10)
potrdf.F:      enddo
potrdf.F:c addition of nuclear potential and division of potentials and                  
potrdf.F:c       their development limits by speed of light                              
potrdf.F:         if (abs(cg(i,ia)).gt.1e-15) then
potrdf.F:         endif
potrdf.F:c         enddo
potrdf.F:c     $        -en(ia)*cg(i,ia),-0.5*ttpsi,cg(i,ia)*kap(ia)
potrdf.F:      end                                                                       
potrdf2.F:c it under the terms of the GNU General Public License as published by
potrdf2.F:c the Free Software Foundation; either version 2 of the License, or
potrdf2.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
potrdf2.F:c GNU General Public License for more details.
potrdf2.F:c You should have received a copy of the GNU General Public License
potrdf2.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
potrdf2.F:      dimension bgj(10),bpj(10),rjunk(npdm)                                                 
potrdf2.F:      dimension at(npdm),bt(npdm),kap(n0)
potrdf2.F:      dimension rvs(npdm),rvn(npdm),anoy(10)
potrdf2.F:      dimension cg(npdm,n0),cp(npdm,n0),xgg(npdm),yrr(npdm)
potrdf2.F:c addition of nuclear potential and division of potentials and                  
potrdf2.F:c     their development limits by speed of light                              
potrdf2.F:         if (abs(cg(i,ia)).gt.1e-10) then
potrdf2.F:         endif
potrdf2.F:c     enddo
potrdf2.F:c     $        -en(ia)*cg(i,ia)/2.d0-0.5*ttpsi+cg(i,ia)*kap(ia)
potrdf2.F:c     $        -en(ia)*cg(i,ia)
potrdf2.F:      if (ipsp.ne.0) then
potrdf2.F:            if (r(k).lt.0.1) then
potrdf2.F:            endif
potrdf2.F:         enddo
potrdf2.F:      endif
potrdf2.F:      end                                                                       
pratt.F:c it under the terms of the GNU General Public License as published by
pratt.F:c the Free Software Foundation; either version 2 of the License, or
pratt.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
pratt.F:c GNU General Public License for more details.
pratt.F:c You should have received a copy of the GNU General Public License
pratt.F:c pratt method applied to accelerate convergence of sc potential
pratt.F:c the value of pratt must lie between 0 and 0.5.
pratt.F:      end
radin.F:c it under the terms of the GNU General Public License as published by
radin.F:c the Free Software Foundation; either version 2 of the License, or
radin.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
radin.F:c GNU General Public License for more details.
radin.F:c You should have received a copy of the GNU General Public License
radin.F:      dimension r(npdm), f(npdm)
radin.F:c     check if there are enough grid points available      
radin.F:      if(np.lt.10) then
radin.F:      endif
radin.F:c     since this is on logarithmic grid increment the power of r by one      
radin.F:      enddo
radin.F:c     determine the endpoint corrections to fourth order      
radin.F:      endpt  = (23.75*(     s1       +f(np  )*(r(np  )**n))
radin.F:c     add end point correction and multiply with width of log. grid
radin.F:      p = (p + endpt) * h
radin.F:      end
schsl.F:c it under the terms of the GNU General Public License as published by
schsl.F:c the Free Software Foundation; either version 2 of the License, or
schsl.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
schsl.F:c GNU General Public License for more details.
schsl.F:c You should have received a copy of the GNU General Public License
schsl.F:c     External (shared between C and Fortran) common blocks
schsl.F:      dimension rv(npdm), p(npdm), phom(npdm)
schsl.F:      dimension pinhom(npdm),wnlfract(npdm)
schsl.F:      enddo
schsl.F:      if (ibound.eq.0) then
schsl.F:      endif
schsl.F:      if (iterm.eq.1) then
schsl.F:c         if (itermcount.gt.5.and.igh.eq.0) then 
schsl.F:c         endif
schsl.F:      endif
schsl.F:         if (bound.and.iclose.eq.0) then
schsl.F:            if (iskip.eq.1) then 
schsl.F:               if (iskipcount.eq.itmax) then 
schsl.F:               endif
schsl.F:            endif
schsl.F:         else if (.not.bound) then
schsl.F:         endif            
schsl.F:c         if (igh.eq.0.and.ipos(iorb).gt.4) then 
schsl.F:c         endif
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      enddo
schsl.F: 9000 format(1x,'!WARNING! : schsl found a positive eigenvalue.',
schsl.F: 9003 format(1x,'!WARNING! : schsl found a positive eigenvalue.',
schsl.F:      end
schsl.F:      dimension psvph(npdm),phvph(npdm),fs(npdm),
schsl.F:      enddo
schsl.F:      effnlden = 2 * lang + 2
schsl.F:      call radin (r, phvph, 0, np, h, effnlden)
schsl.F:      if (abs(effnlden).le.1e-10) then 
schsl.F:        eff=effnlnum/effnlden
schsl.F:            if (abs(pg(i)).gt.1e-10) then
schsl.F:            endif
schsl.F:         enddo
schsl.F:      endif
schsl.F:      end
schsl.F:      dimension wnlf(npdm),rv(npdm),v(npdm)
schsl.F:      enddo
schsl.F:      if (lang.ne.0) then
schsl.F:         enddo
schsl.F:         if (elim.ge.0.0) then
schsl.F:         endif
schsl.F:      endif
schsl.F:      end
schsl.F:      dimension rv(npdm),v(npdm),wnlf(npdm)
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      if (imat.le.2) then
schsl.F:c     if (ei.ge.-etol.or.ncross.gt.node) then
schsl.F:         if (ei.ge.-etol) then
schsl.F:         endif
schsl.F:      endif
schsl.F:      if (inl.ne.0) then
schsl.F:         enddo
schsl.F:         if (imat.lt.indmax) then
schsl.F:         endif
schsl.F:         if (imat.lt.IB) then
schsl.F:         endif
schsl.F:         if (imat.lt.ID) then
schsl.F:         endif
schsl.F:         if (imat.lt.IG) then
schsl.F:         endif
schsl.F:      endif
schsl.F:      end
schsl.F:      dimension a(npdm),phom(npdm),pinhom(npdm),rv(npdm)
schsl.F:      dimension dl(n0),dld(5),g(npdm),fs(npdm),pref(npdm)
schsl.F:      dimension flph(npdm),flw(npdm),flx(npdm),p(npdm)
schsl.F:      enddo
schsl.F:      if (inl.ne.0) then
schsl.F:         enddo
schsl.F:      endif
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      if (abs(flinv).le.1e-10) then
schsl.F:      endif
schsl.F:      if (inl.eq.0) then wt = 0
schsl.F:      enddo
schsl.F:      end
schsl.F:      dimension p(npdm)
schsl.F:      enddo
schsl.F:      if (ncross.ne.node) then
schsl.F:         if (ncross.lt.node) then
schsl.F:            if (ietoolo.gt.2.and.ei.ge.-etol) then
schsl.F:            endif
schsl.F:            if (ietoohi.gt.2.and.ei.lt.elim) then
schsl.F:            endif
schsl.F:         endif
schsl.F:      endif
schsl.F:      end
schsl.F:      dimension rv(npdm),p(npdm)
schsl.F:      dimension rho(npdm)
schsl.F:      dimension v(npdm),pinhom(npdm),xai(npdm),xci(npdm),xdi(npdm)
schsl.F:      dimension xli(npdm),phom(npdm),xah(npdm),xch(npdm)
schsl.F:      dimension xdh(npdm),xlh(npdm),g(npdm),fs(npdm)
schsl.F:      enddo
schsl.F:      if (iclose.eq.0) then
schsl.F:         enddo
schsl.F:      endif
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      end
schslrel.F:c it under the terms of the GNU General Public License as published by
schslrel.F:c the Free Software Foundation; either version 2 of the License, or
schslrel.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
schslrel.F:c GNU General Public License for more details.
schslrel.F:c You should have received a copy of the GNU General Public License
schslrel.F:c     find eigenvalue ev and the major and minor
schslrel.F:c     components of the wavefunction, ar and br
schslrel.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
schslrel.F:      dimension v(nrmax),ar(nrmax),br(nrmax)
schslrel.F:      dimension 
schslrel.F:c     eigenvalue tolerance and max number of iterations
schslrel.F:c     integration coefficients
schslrel.F:c     these are used to bracket eigenvalue
schslrel.F:c     max step size for eigenvalue changes
schslrel.F:      enddo
schslrel.F:c            if (r(j) .gt. rwell) then
schslrel.F:c            end if
schslrel.F:c            if (r(j)*r(j)*(v(j)-ev(iorb)) .gt. 750) then
schslrel.F:            if (r(j)*r(j)*(v(j)/r(j)-ev(iorb)) .gt. log(tol)**2) then
schslrel.F:            end if
schslrel.F:            if (v(j)/r(j) .gt. ev(iorb)) then
schslrel.F:            end if
schslrel.F:c     end outward integration
schslrel.F:c     if incorrect number of nodes modify energy stepwise
schslrel.F:         if (nodes .gt. no(iorb)-lo(iorb)-1) then
schslrel.F:         else if (nodes .lt. no(iorb)-lo(iorb)-1) then
schslrel.F:         end if
schslrel.F:         if (ninf .eq. np) then
schslrel.F:         end if
schslrel.F:            if (ninf .lt. np) then
schslrel.F:            end if
schslrel.F:c     end inward integration
schslrel.F:         enddo
schslrel.F:c     modify eigenvalue ev
schslrel.F:         if (abs(dev) .gt. abs(devmax)) then
schslrel.F:         end if
schslrel.F:c     eigenpar not converged in itmax iterations
schslrel.F:      if (nodes .ne. no(iorb)-lo(iorb)-1) then
schslrel.F:         enddo
schslrel.F:      endif
schslrel.F:c         enddo
schslrel.F:c      end if
schslrel.F:c         if (nodes.gt.12) then
schslrel.F:c            write(7,*) 'Doing reset of this eigenvalue',ev(iorb)
schslrel.F:c            write(7,*) 'New value', en(iorb)
schslrel.F:c         endif
schslrel.F:      enddo
schslrel.F:c      enddo
schslrel.F:      enddo
schslrel.F:      end
setuphf.F:c it under the terms of the GNU General Public License as published by
setuphf.F:c the Free Software Foundation; either version 2 of the License, or
setuphf.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
setuphf.F:c GNU General Public License for more details.
setuphf.F:c You should have received a copy of the GNU General Public License
setuphf.F:c     determine the self-consistent solution
setuphf.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
setuphf.F:      dimension epss(npdm),ka(n0),scc(n0),anoy(10)
setuphf.F:      enddo
setuphf.F:            if (ka(j).eq.ka(i)) then
setuphf.F:            endif
setuphf.F:         enddo
setuphf.F:         if (ipsp.eq.0) en(i)=-z*z/(2.d0*no(i)*no(i))
setuphf.F:         if (ipsp.ne.0) en(i)=en(i)/2.d0
setuphf.F:      enddo
setuphf.F:      enddo
setuphf.F:      enddo
setuphf.F:            rvps(i,k)=(dentfa(r(i),zeff,ch)+rvcore(i,k)/(2.d0*r(i)))/cl
setuphf.F:         enddo
setuphf.F:      enddo
setuphf.F:      enddo
setuphf.F:      av(2)=av(2)+dentfa(r(1),zeff,ch)/cl
setuphf.F:         if (ka(j).ge.0) then
setuphf.F:         endif
setuphf.F:     $        (j,no(j),lo(j),en(j), fl(j),bg(1,j),bp(1,j),rvps(1,j), 
setuphf.F:c         write(7,'(4i5,4f10.6)') j,ka(j),no(j),lo(j),so(j),wnl(j),en(j)
setuphf.F:         enddo
setuphf.F:         enddo
setuphf.F:      enddo                        
setuphf.F:      end
soldir.F:c it under the terms of the GNU General Public License as published by
soldir.F:c the Free Software Foundation; either version 2 of the License, or
soldir.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
soldir.F:c GNU General Public License for more details.
soldir.F:c You should have received a copy of the GNU General Public License
soldir.F:      subroutine soldir(iorb,nqn,lang,en,fl,agi,api,dv,
soldir.F:c     External (shared between C and Fortran) common blocks
soldir.F:      dimension hg(npdm),hp(npdm)
soldir.F:      dimension dv(npdm),bg(npdm),bp(npdm)
soldir.F:      dimension agh(10),aph(10),bgh(10),bph(10)
soldir.F:      enav=1.0d 00                                                              
soldir.F:c      write(7,*) 'entered soldir',iex,method,agi,api
soldir.F:      if (emin .ge. 0.0) then                                                   
soldir.F:      endif                                                                     
soldir.F:      if (en.lt.emin) en=emin*0.9d 00                                           
soldir.F:      edep=en                                                                   
soldir.F:      en=edep                                                                   
soldir.F:      if ( abs((enav-en)/en).lt.1.0d-01) imm=1                                  
soldir.F:      enav=en                                                                   
soldir.F:c      write(7,*) 'entered soldir2',iex,method
soldir.F:c     integration of the inhomogenious system                                   
soldir.F:c         write(7,*) 'before first int test1=',en
soldir.F:      call intdir (gg,gp,ag,ap,ggmat,gpmat,en,dv,av,
soldir.F:c      write(7,*) 'after first int iex, test1=',en
soldir.F:c     match large component for the homogenios system(method=0)                 
soldir.F:c     integration of the homogenios system                                      
soldir.F:      call intdir (hg,hp,agh,aph,hgmat,hpmat,en,dv,av,
soldir.F:c     match the large component for inhomogenious system(method=1)              
soldir.F:      if (method.lt.2) then                                                     
soldir.F:      endif                                                                     
soldir.F:      if (method.ge.2) then                                                     
soldir.F:c        integration of the system derived from disagreement in energy          
soldir.F:         call intdir (bg,bp,bgh,bph,bgmat,bpmat,en,dv,av,
soldir.F:c        match both components for inhomogenious system (method=2)              
soldir.F:c        correction to the energy (method=2)                                    
soldir.F:      endif                                                                     
soldir.F:c     search for the maximum of the modulus of large component                  
soldir.F:      if (j.gt.mat .and. modmat.eq.0) then                                      
soldir.F:      endif                                                                     
soldir.F:c this case can happen due to bad starting point in scf procedure.              
soldir.F:c      write(7,*) 'nodes',nd,node,en
soldir.F: 251  esup=en                                                                   
soldir.F:      en=en*8.0d-01                                                             
soldir.F:      if ( abs(en).gt.test1) go to 285                                          
soldir.F:c    *zero energy                                                               
soldir.F: 261  einf=en     
soldir.F:c      write(7,*) 'eee',einf,en,esup,emin
soldir.F: 263  en=en*1.2d 00                                                             
soldir.F:      if (en.gt.emin) go to 285                                                 
soldir.F:c    *energy is lower than the minimum of apparent potential                    
soldir.F:c    *the upper and lower limits of energy are identical                        
soldir.F: 281  en=(einf+esup)/2.0d 00                                                    
soldir.F:c this case can happen due to bad starting point in scf procedure.              
soldir.F:      if (method.eq.1) then                                                     
soldir.F:c        correction to the energy (method=1)                                    
soldir.F:      endif                                                                     
soldir.F:      en=en+f                                                                   
soldir.F:      g= abs(f/(en-f))  
soldir.F:c      write(7,*) 'adj1',en
soldir.F: 371  if ((en.ge.0 .or. g.gt.2.0d-01) .or.                                      
soldir.F:     1 (abs(c).gt.test .and. (en.lt.esup.or.en.gt.einf))) then                  
soldir.F:c        try smaller step in enrgy under above conditions                       
soldir.F:         en=en-f                                                                
soldir.F:c         write(7,*) 'adjusted f',f,g,en
soldir.F:      endif                                                                     
soldir.F:c      write(7,*) 'after norm', b,en,ies
soldir.F:      if ( abs(c).gt.test)  then                                                
soldir.F:c     on the latest stage selfconsistent process.                               
soldir.F:c     just stopped trying to match lower component                              
soldir.F:c     lines below were commented out.  ala 11/18/94                             
soldir.F:      endif                                                                     
soldir.F:      end                                                                       
xch.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
xch.F:c it under the terms of the GNU General Public License as published by
xch.F:c the Free Software Foundation; either version 2 of the License, or
xch.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
xch.F:c GNU General Public License for more details.
xch.F:c You should have received a copy of the GNU General Public License
xch.F:c     get the hartree potential function
xch.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
xch.F:      dimension yk(npdm),yr(npdm),x(npdm)
xch.F:      dimension meth(10)
xch.F:      enddo
xch.F:         if (j .ne. i) then
xch.F:               if (dabs(bbb(i,j,k)) .ge. 1.d-10) then
xch.F:                      !if (ixc.eq.7) then
xch.F:                      !endif
xch.F:                  enddo
xch.F:               endif
xch.F:            enddo
xch.F:         endif
xch.F:      enddo
xch.F:      if (iopt.eq.2) then
xch.F:         enddo
xch.F:      endif
xch.F:      if (iopt.eq.3) then
xch.F:         enddo
xch.F:      endif
xch.F:      if (iopt.eq.3) then
xch.F:            if (dabs(c).gt.1.d-10.and.(j.ne.i)) then
xch.F:                  !if (ixc.eq.7) then
xch.F:                  !endif
xch.F:               enddo
xch.F:            endif
xch.F:         enddo
xch.F:      endif
xch.F:      end
ykf.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
ykf.F:c it under the terms of the GNU General Public License as published by
ykf.F:c the Free Software Foundation; either version 2 of the License, or
ykf.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
ykf.F:c GNU General Public License for more details.
ykf.F:c You should have received a copy of the GNU General Public License
ykf.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
ykf.F:      dimension yk(npdm)
ykf.F:      enddo
ykf.F:      end
yzkrdf.F:c it under the terms of the GNU General Public License as published by
yzkrdf.F:c the Free Software Foundation; either version 2 of the License, or
yzkrdf.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
yzkrdf.F:c GNU General Public License for more details.
yzkrdf.F:c You should have received a copy of the GNU General Public License
yzkrdf.F:c tabulated untill point dr(j), and its' devlopment coefficients                
yzkrdf.F:c at the origin  yk = cte * r**(k+1) - developement limit,                      
yzkrdf.F:c cte lies in ap(1) and development coefficients in ag.                         
yzkrdf.F:c      common/ratom1/xnel(N0),en(N0),scc(N0),scw(N0),sce(N0),                    
yzkrdf.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
yzkrdf.F:      dimension chg(10)                                                         
yzkrdf.F:      dimension bgi(10),bgj(10),bpi(10),bpj(10)                                 
yzkrdf.F:      dimension cg(npdm,n0),cp(npdm,n0)
yzkrdf.F:      end                                                                       
yzkteg.F:c it under the terms of the GNU General Public License as published by
yzkteg.F:c the Free Software Foundation; either version 2 of the License, or
yzkteg.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
yzkteg.F:c GNU General Public License for more details.
yzkteg.F:c You should have received a copy of the GNU General Public License
yzkteg.F:c dr tabulation points   h exponential step                                     
yzkteg.F:c idim dimension of the blocks f,g and dr                                       
yzkteg.F:c at the origin yk=cte*r**(k+1)-developement limit                              
yzkteg.F:c development coefficients at the origin in af and ag.                          
yzkteg.F:      dimension f(npdm),af(10),g(npdm),ag(10),dr(npdm)                             
yzkteg.F:c    initialisation and development coefficients of yk                          
yzkteg.F:         if (af(i).ne.0.0d 00) then                                             
yzkteg.F:         endif                                                                  
yzkteg.F:      end                                                                       
zkf.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
zkf.F:c it under the terms of the GNU General Public License as published by
zkf.F:c the Free Software Foundation; either version 2 of the License, or
zkf.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
zkf.F:c GNU General Public License for more details.
zkf.F:c You should have received a copy of the GNU General Public License
zkf.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
zkf.F:      dimension yk(npdm)
zkf.F:      enddo
zkf.F:      den=lo(i)+lo(j)+3+k
zkf.F:      fact = (1.d0/(lo(i)+1) + 1.d0/(lo(j)+1))/(den + 1.d0)
zkf.F:      !if (ixc.eq.7) then
zkf.F:      !endif
zkf.F:      yk(1) = f1*(1.d0 + z*r(1)*fact)/den
zkf.F:      yk(2) = f2*(1.d0 + z*r(2)*fact)/den
zkf.F:         !if (ixc.eq.7) then
zkf.F:         !endif
zkf.F:      enddo
zkf.F:      if (iabs(i-j)  +  iabs(k) .eq. 0) then
zkf.F:         enddo 
zkf.F:      endif
zkf.F:      enddo
zkf.F:      end
