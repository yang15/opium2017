akeato.F:c it under the terms of the GNU General Public License as published by
akeato.F:c the Free Software Foundation; either version 2 of the License, or
akeato.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
akeato.F:c GNU General Public License for more details.
akeato.F:c You should have received a copy of the GNU General Public License
akeato.F:c     angular coefficient by the direct coulomb integral fk                     
akeato.F:c     afgk angular coefficients by integrales fk and gk                         
akeato.F:c        coefficient of integral fk(i;j) is in  afgk(min,max)                   
akeato.F:      if (i .le. j) then                                                        
akeato.F:      endif                                                                     
akeato.F:      entry bkeato (i,j,k)                                                      
akeato.F:c angular coefficient at the exchange coulomb integral gk                       
akeato.F:      if (i .lt. j) then                                                        
akeato.F:      elseif (i.gt.j) then                                                      
akeato.F:      endif                                                                     
akeato.F:      end                                                                       
aprdev.F:c it under the terms of the GNU General Public License as published by
aprdev.F:c the Free Software Foundation; either version 2 of the License, or
aprdev.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
aprdev.F:c GNU General Public License for more details.
aprdev.F:c You should have received a copy of the GNU General Public License
aprdev.F:c     the result of this function is the coefficient of the term of             
aprdev.F:c     power for the product of two polynomes, whose coefficients are            
aprdev.F:      dimension a(10),b(10)                                                     
aprdev.F:      end                                                                       
average.F:c it under the terms of the GNU General Public License as published by
average.F:c the Free Software Foundation; either version 2 of the License, or
average.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
average.F:c GNU General Public License for more details.
average.F:c You should have received a copy of the GNU General Public License
average.F:c     This routine was originally written by I. Grinberg and cleaned up by EJW
average.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
average.F:      dimension rvxct(npdm),rexct(npdm),v(npdm)
average.F:      dimension ibp(n0),indall(n0),rsatom(npdm),rv(npdm)
average.F:      dimension fe_old(n0),fe(n0), rnlt(npdm,n0)
average.F:      dimension rvscr(npdm),rvh(npdm),phom(npdm)
average.F:      dimension xah(npdm),xdh(npdm),xch(npdm),xlh(npdm)
average.F:      dimension rhowf(npdm),temp1(npdm),temp2(npdm)
average.F:      dimension ratio(n0),tempx(npdm)
average.F:      dimension enrel(n0)
average.F:      common /filenames/ file_log
average.F:      open(unit=7,file=file_log,form='formatted',access='append')
average.F:      enddo
average.F:c     Keep a copy of rel eigenvalues, eigenvalues come into 
average.F:c     this routine in "en" and are copied into enrel.
average.F:c     first get the core eigenvalues
average.F:            if (lo(k).gt.0.or.j.eq.1) then
average.F:               enrel(norb_rel)=en(norb_rel)
average.F:            endif
average.F:         enddo
average.F:      enddo
average.F:c     now get the valence eigenvalues
average.F:            if (lo(k).gt.0.or.j.eq.1) then
average.F:               enrel(norb_rel)=en(norb_rel)
average.F:            endif
average.F:         enddo
average.F:      enddo
average.F:c     to be based on when charge density vanished
average.F:      enddo
average.F:         enddo
average.F:c     if we are NOT an 's' state, then grab next wfn         
average.F:         enddo
average.F:      enddo
average.F:         enddo
average.F:c     if we are NOT an 's' state, then grab next wfn
average.F:c     add in the j- component
average.F:         enddo
average.F:         enddo
average.F:         if (iavgtype.eq.0) then
average.F:         endif
average.F:      enddo
average.F:         enddo
average.F:         enddo
average.F:         enddo
average.F:         enddo
average.F:         enddo
average.F:      enddo
average.F:      enddo
average.F:         if (ibd(ic).ne.0) then
average.F:            enddo
average.F:            enddo
average.F:         endif
average.F:      enddo
average.F:         enddo
average.F:c     3a: Find new xc and hartree potentials since rho has changed
average.F:c     rvscr is the screening potential
average.F:c     rv is the effective potential
average.F:         enddo
average.F:c     potential and the reference eigenvalues
average.F:            if (ibd(ic).eq.0) then
average.F:            endif
average.F:            ei=enrel(kk)*xd
average.F:            ei=ei+enrel(kk)*xu
average.F:            enddo
average.F:            enddo
average.F:            enddo
average.F:            enddo
average.F:         enddo
average.F:            enddo
average.F:            enddo
average.F:            enddo
average.F:            enddo
average.F:            enddo
average.F:            enddo
average.F:            enddo
average.F:         enddo
average.F:c     kind of wasteful but ok (since we are self-consistent at this point).
average.F:         enddo
average.F:         if(abs(rttot).lt.(1e-12)) then 
average.F:         endif
average.F:         enddo
average.F:            if (ibd(ic).ne.0) then
average.F:               enddo
average.F:            endif
average.F:         enddo
average.F:      enddo
average.F:         if (ibd(ic).ne.0) then
average.F:         endif
average.F:      enddo
average.F: 9016 format(5x,"Final averaged tail norms and eigenvalues: ...")
average.F:         en(ic)=enrel(kk)*xd
average.F:         en(ic)=en(ic)+enrel(kk)*xu
average.F:         enddo
average.F:         if (ibd(ic).ne.0) then
average.F:         endif
average.F:      enddo
average.F:      enddo
average.F:      enddo
average.F:      if (dif1.gt.tol2) then
average.F:        write (7,*) 'Use more grid points. Potentials inaccurately '
average.F:        write (7,*) 'integrated from charge density. ',tol2
average.F:      endif
average.F:         enddo
average.F:      enddo
average.F:c     print final average eigenvalues
average.F:         write(7,9070) no(i),xc(lo(i)+1),en(ic)
average.F:            if (abs(rnl(k,ic)).gt.1e-10) then
average.F:               if (rnl(k,ic).lt.0.0) then
average.F:                  enddo
average.F:               endif
average.F:            endif
average.F:         enddo
average.F:         enddo
average.F:      enddo      
average.F: 9010 format(5x,"Z valence                         :",f10.6)
average.F: 9020 format(5x,"Total valence charge              :",f10.6)
average.F: 9030 format(1x,i1,a1,2x,"- eigenvalue                      :",f10.6)
average.F: 9040 format(1x,i1,a1,2x,"+ eigenvalue                      :",f10.6)
average.F: 9070 format(1x,i1,a1,2x,"Avg. eigenvalue                   : ",f10.6)
average.F:      end
cofcon.F:c it under the terms of the GNU General Public License as published by
cofcon.F:c the Free Software Foundation; either version 2 of the License, or
cofcon.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
cofcon.F:c GNU General Public License for more details.
cofcon.F:c You should have received a copy of the GNU General Public License
cofcon.F:c         acceleration of the convergence in the iterative process              
cofcon.F:c b is between 0.1 and 0.9                                                      
cofcon.F:c             ** at the end makes q=p                                           
cofcon.F:      end                                                                       
corpz.F:c it under the terms of the GNU General Public License as published by
corpz.F:c the Free Software Foundation; either version 2 of the License, or
corpz.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
corpz.F:c GNU General Public License for more details.
corpz.F:c You should have received a copy of the GNU General Public License
corpz.F:c     Low density correlation
corpz.F:c     High density correlation
corpz.F:      end
corvwn.F:c it under the terms of the GNU General Public License as published by
corvwn.F:c the Free Software Foundation; either version 2 of the License, or
corvwn.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
corvwn.F:c GNU General Public License for more details.
corvwn.F:c You should have received a copy of the GNU General Public License
corvwn.F:      end
cubint.F:c it under the terms of the GNU General Public License as published by
cubint.F:c the Free Software Foundation; either version 2 of the License, or
cubint.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
cubint.F:c GNU General Public License for more details.
cubint.F:c You should have received a copy of the GNU General Public License
cubint.F:c  homogeneous or inhomogeneous solutions to the integro-differential
cubint.F:c     External (shared between C and Fortran) common blocks
cubint.F:      dimension rv(npdm),dl(6),pder(npdm),w(5),g(npdm)
cubint.F:      dimension rvtemp(6),rtemp(6),pdertemp(6),gtemp(6)
cubint.F:      if (rphas.lt.rcall(iorb)) then
cubint.F:      endif
cubint.F:c  exponential grid and determine the 4 nearest linear grid points 
cubint.F:c  plog is the numerical representation of rphas on the linear grid.  
cubint.F:c  determination of the distance on the linear grid between the actual
cubint.F:c  determination of cooefficients of each value of the function to be
cubint.F:c  The points are taken to be at (-3/2)[iplog-1], (-1/2)[iplog],
cubint.F:      end
cwig3j.F:c it under the terms of the GNU General Public License as published by
cwig3j.F:c the Free Software Foundation; either version 2 of the License, or
cwig3j.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
cwig3j.F:c GNU General Public License for more details.
cwig3j.F:c You should have received a copy of the GNU General Public License
cwig3j.F:      double precision function cwig3j (j1,j2,j3,m1,m2,ient)                    
cwig3j.F:c        wigner 3j coefficient for integers  (ient=1)                           
cwig3j.F:c                            or semiintegers (ient=2)                           
cwig3j.F:c        other arguments should be multiplied by ient                           
cwig3j.F:      dimension al(32),m(12)                                                    
cwig3j.F:c     idim-1 is the largest argument of factorial in calculations               
cwig3j.F:      if (((ient-1)*(ient-2)).ne.0) go to 101                                   
cwig3j.F:      ii=ient+ient                                                              
cwig3j.F:      m(10)=j1+j2+j3+ient                                                       
cwig3j.F: 31      if (mod(m(i),ient).ne.0) go to 101                                     
cwig3j.F:         m(i)=m(i)/ient                                                         
cwig3j.F:c  calculate 3j coefficient                                                     
cwig3j.F:c      write(7,9222) cwig3j,j1,j2,j3,m1,m2,ient
cwig3j.F: 101     write(slog,'(a,6i5)') 'error in cwig3j ',j1,j2,j3,m1,m2,ient           
cwig3j.F:      end                                                                       
denkcomp.F:c it under the terms of the GNU General Public License as published by
denkcomp.F:c the Free Software Foundation; either version 2 of the License, or
denkcomp.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
denkcomp.F:c GNU General Public License for more details.
denkcomp.F:c You should have received a copy of the GNU General Public License
denkcomp.F:      subroutine denkcomp(name,rkstor,ikstor)
denkcomp.F:      dimension pl(5000),rtemp(npdm),rke(5000),rkstor(3)
denkcomp.F:      dimension ikstor(3)
denkcomp.F:      open(unit=7,file=file_log,form='formatted',access='append')
denkcomp.F:      open(unit=71,file=name,form='formatted')
denkcomp.F:      write(7,*) '              PCC KE convergence  '
denkcomp.F:      enddo
denkcomp.F:         enddo
denkcomp.F:      enddo
denkcomp.F:            if ((rkkm.lt.100).and.(rkkmlast.gt.100)) then
denkcomp.F:            endif
denkcomp.F:            if ((rkkm.lt.10).and.(rkkmlast.gt.10)) then
denkcomp.F:            endif
denkcomp.F:            if ((rkkm.lt.1).and.(rkkmlast.gt.1)) then
denkcomp.F:            endif
denkcomp.F:         enddo
denkcomp.F:      end
dentfa.F:c it under the terms of the GNU General Public License as published by
dentfa.F:c the Free Software Foundation; either version 2 of the License, or
dentfa.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
dentfa.F:c GNU General Public License for more details.
dentfa.F:c You should have received a copy of the GNU General Public License
dentfa.F:      double precision function dentfa (dr,dz,ch)                               
dentfa.F:c     analitical approximation of potential is created for electrons in         
dentfa.F:      dentfa=0.0d 00                                                            
dentfa.F:      dentfa=(dz+ch)*(1.0d 00-(t/w)**2)/dr                                      
dentfa.F:      end                                                                       
dfsolve.F:c it under the terms of the GNU General Public License as published by
dfsolve.F:c the Free Software Foundation; either version 2 of the License, or
dfsolve.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
dfsolve.F:c GNU General Public License for more details.
dfsolve.F:c You should have received a copy of the GNU General Public License
dfsolve.F:c     determine the self-consistent solution
dfsolve.F:c     External (shared between C and Fortran) common blocks
dfsolve.F:      common /filenames/ file_log
dfsolve.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
dfsolve.F:      dimension sce(n0),scw(n0)
dfsolve.F:      dimension wavea(npdm),icarray(30)
dfsolve.F:      dimension epss(npdm),ka(n0),scc(n0)
dfsolve.F:      dimension rhart(npdm),xg(npdm)
dfsolve.F:      open(unit=7,file=file_log,form='formatted',access='append')
dfsolve.F:c         if (wnl(j).lt.1e-8) then
dfsolve.F:c         endif
dfsolve.F:         enddo
dfsolve.F:      enddo
dfsolve.F:      enddo
dfsolve.F:      e=en(j)
dfsolve.F:      call soldir(j,no(j),lo(j),en(j),
dfsolve.F: 111  sce(j)=abs((e-en(j))/en(j))
dfsolve.F:      enddo
dfsolve.F:     $     nter,j,en(j)*2.d0,sce(j)*2.d0,pr*2.d0
dfsolve.F:      enddo
dfsolve.F:      enddo
dfsolve.F:      enddo
dfsolve.F:      enddo
dfsolve.F:      if ((nter.lt.norb).or.(ind.lt.0.and.j.lt.norb)) then
dfsolve.F:      endif
dfsolve.F:         if (w.gt.pr) then
dfsolve.F:         endif
dfsolve.F:      enddo
dfsolve.F:         if (w.gt.pr) then
dfsolve.F:         endif
dfsolve.F:      enddo
dfsolve.F:      if (numerr.eq.0) then         
dfsolve.F:         if (jfail.ne.0) then
dfsolve.F:            stop 'lower component not matched'
dfsolve.F:         endif
dfsolve.F:      endif
dfsolve.F:            if (ka(j).gt.0) then
dfsolve.F:            endif
dfsolve.F:         en(i)=en(i)*2.d0
dfsolve.F:         enddo
dfsolve.F:      enddo
dfsolve.F:      if (ipsp.eq.0) then
dfsolve.F:            enddo
dfsolve.F:         enddo
dfsolve.F:            enddo
dfsolve.F:         enddo
dfsolve.F:      endif
dfsolve.F:            if (abs(rnlb(j,i)).gt.1e-10) then
dfsolve.F:            endif
dfsolve.F:         enddo
dfsolve.F:         if (rnlb(nmax(i)-1,i).lt.0.0) then
dfsolve.F:            enddo
dfsolve.F:         endif
dfsolve.F:            if (abs(rnla(j,i)).gt.1e-10) then
dfsolve.F:            endif
dfsolve.F:         enddo
dfsolve.F:         if (rnla(nmax(i)-1,i).lt.0.0) then
dfsolve.F:            enddo
dfsolve.F:         endif
dfsolve.F:      enddo
dfsolve.F:c     compute valence density 
dfsolve.F:      enddo
dfsolve.F:         if (irel.eq.0) then
dfsolve.F:            enddo
dfsolve.F:            enddo
dfsolve.F:         endif
dfsolve.F:      enddo
dfsolve.F:c     compute core density
dfsolve.F:      if (ipsp.eq.0) then
dfsolve.F:         enddo
dfsolve.F:            if (irel.eq.0) then
dfsolve.F:               enddo
dfsolve.F:               enddo
dfsolve.F:            endif
dfsolve.F:         enddo
dfsolve.F:      endif
dfsolve.F:c     loop over valence
dfsolve.F:         enddo
dfsolve.F:      enddo
dfsolve.F:            if (rnla(j,i).lt.rnla(j+1,i)) then
dfsolve.F:     $              and.(abs(rnla(j,i)).gt.1e-6)) then
dfsolve.F:               endif
dfsolve.F:            endif
dfsolve.F:         enddo
dfsolve.F:      enddo
dfsolve.F:      if (niter.eq.1) then
dfsolve.F:      endif
dfsolve.F:         if (iprint.gt.0) then 
dfsolve.F:            if (lo(i).eq.0) then
dfsolve.F:               write (7,9523) nlm(i),wnl(i),en(i)
dfsolve.F:               if (so(i).lt.0) then
dfsolve.F:                  write (7,9323) nlm(i),wnl(i),en(i)
dfsolve.F:                  write (7,9423) nlm(i),wnl(i),en(i)
dfsolve.F:               endif
dfsolve.F:            endif
dfsolve.F:         endif
dfsolve.F:      enddo
dfsolve.F:         if (iprint.gt.0) then
dfsolve.F:            if (lo(i).eq.0) then
dfsolve.F:               write (7,9523) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
dfsolve.F:               if (so(i).lt.0) then
dfsolve.F:                  write (7,9323) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
dfsolve.F:                  write (7,9423) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
dfsolve.F:               endif
dfsolve.F:            endif
dfsolve.F:         endif
dfsolve.F:      enddo
dfsolve.F:         enddo
dfsolve.F:      enddo
dfsolve.F: 700  format(1x,'Converged in 1 iteration (probably reference state)')
dfsolve.F: 9222 format(3x,'Orbital',4x,'Filling',7x,'Eigenvalues',4x,
dfsolve.F:      write(7,*) " !!ERROR!! Could not find self-consistent solution!"
dfsolve.F:     +     ' number of valence orbitals =',i3,/,
dfsolve.F:      end
dftsolve.F:c it under the terms of the GNU General Public License as published by
dftsolve.F:c the Free Software Foundation; either version 2 of the License, or
dftsolve.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
dftsolve.F:c GNU General Public License for more details.
dftsolve.F:c You should have received a copy of the GNU General Public License
dftsolve.F:c     determine the self-consistent solution
dftsolve.F:c     External (shared between C and Fortran) common blocks
dftsolve.F:      common /filenames/ file_log
dftsolve.F:      common /box/ iboxstart(n0),iboxend(n0),boxheight(n0),numbox
dftsolve.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
dftsolve.F:      dimension rvn(npdm),rvf(npdm),eold(n0),p(npdm)
dftsolve.F:      dimension rsatom(npdm),f(npdm),f2(npdm),f3(npdm)
dftsolve.F:      dimension pder(npdm),ader(npdm)
dftsolve.F:      dimension dl(n0), rsatom2(npdm)
dftsolve.F:      dimension rsold(npdm),wnlfract(npdm)
dftsolve.F:      dimension wavea(npdm),icarray(n0)
dftsolve.F:      open(unit=7,file=file_log,form='formatted',access='append')
dftsolve.F:c     User supplied eigenvalue guesses were never used in the SRL
dftsolve.F:      if (irel.eq.1) then
dftsolve.F:            en(i)=-z*z/(no(i)*no(i))
dftsolve.F:         enddo
dftsolve.F:            if (ibd(i).ne.0) en(ii)=-z*z/(no(ii)*no(ii))
dftsolve.F:         enddo
dftsolve.F:      endif
dftsolve.F:c      if (ipsp.eq.1) then
dftsolve.F:c            write(7,*) i,en(i),no(i),lo(i),so(i),ibd(i)
dftsolve.F:c         enddo
dftsolve.F:c      endif
dftsolve.F:      write(7,*) '---------Eigenvalue guesses---------'      
dftsolve.F:         write(7,9339) no(i),xc(lo(i)),en(i)
dftsolve.F:      enddo
dftsolve.F:      if (ipsp.eq.1) then
dftsolve.F:      endif
dftsolve.F:      if (inl.ne.0) then
dftsolve.F:            enddo
dftsolve.F:         enddo
dftsolve.F:      endif
dftsolve.F:      if (ifc.eq.0) then
dftsolve.F:            eold(j) = en(j)
dftsolve.F:            if (irel.eq.0) then
dftsolve.F:               enddo
dftsolve.F:               enddo
dftsolve.F:            endif               
dftsolve.F:         enddo
dftsolve.F:      endif
dftsolve.F:      if (inl.ne.0) then
dftsolve.F:          enddo
dftsolve.F:        enddo
dftsolve.F:      endif
dftsolve.F:      enddo
dftsolve.F:      if (inl.ne.0) then
dftsolve.F:        write(7,*)"Performing non-local pseudopotential calculation"
dftsolve.F:         if (ipsp.ne.0) then
dftsolve.F:       write(7,*) "Performing semi-local pseudopotential calculation"
dftsolve.F:         endif
dftsolve.F:      endif
dftsolve.F:      if (ipsp.eq.1.and.inl.ne.0) then
dftsolve.F:      endif
dftsolve.F: 9600 format(1x,'Using the ',a1,' potential as the local potential')
dftsolve.F:      if (ipsp.eq.1.and.inl.ne.0.and.numbox.gt.0) then
dftsolve.F:         enddo
dftsolve.F:            write(7,9240) i,r(iboxstart(i)),r(iboxend(i)),boxheight(i) 
dftsolve.F:            if (r(iboxend(i)).gt.rindmin) ioutmin = 1
dftsolve.F:            if (r(iboxend(i)).gt.rindmax) ioutmax = 1
dftsolve.F:         enddo
dftsolve.F:      endif
dftsolve.F: 9220 format(1x,'--Augmentation operator info--')
dftsolve.F: 9250 format(1x,'NOTE: One or more functions extend beyond the',
dftsolve.F: 9260 format(1x,'WARNING!: One or more functions extend beyond the',
dftsolve.F:c     Begin self-consistency loop.
dftsolve.F:         if (niter.eq.1) then
dftsolve.F:            enddo
dftsolve.F:         endif
dftsolve.F:         enddo
dftsolve.F:c     Section 3:  call schsl for each orbital & compile charge density.
dftsolve.F:            if (m.le.ncore) then
dftsolve.F:            endif
dftsolve.F:            if (ifc.eq.0.or.m.gt.ncore) then
dftsolve.F:c     if not a frozen core calc or if valence
dftsolve.F:               if (irel.eq.0) then
dftsolve.F:                  if (inl.ne.0) then
dftsolve.F:                     enddo
dftsolve.F:                     call schsl (m,no(m),lo(m),en(m),nmax(m),
dftsolve.F:                     enddo
dftsolve.F:                     call schsl(m,no(m),lo(m),en(m),nmax(m),
dftsolve.F:                  endif
dftsolve.F:                  enddo
dftsolve.F:                  enddo                  
dftsolve.F:                  edif = abs((en(m) - eold(m))/eold(m))
dftsolve.F:                  eold(m) = en(m)
dftsolve.F:     $                 rnlb(1,m),z,rvcoul,en,nmax(m),ibound)
dftsolve.F:                  enddo
dftsolve.F:                  enddo                  
dftsolve.F:                  edif = abs((en(m) - eold(m))/eold(m))
dftsolve.F:                  eold(m) = en(m)
dftsolve.F:               endif
dftsolve.F:c     if not a frozen core calc or if valence 
dftsolve.F:            endif
dftsolve.F:         enddo
dftsolve.F:         if(maxim.eq.0) then
dftsolve.F:         endif
dftsolve.F:c     Section 4:  mix density
dftsolve.F:         if (niter.gt.3) then
dftsolve.F:            enddo
dftsolve.F:         endif
dftsolve.F:c     Section 5:  update self-consistent potentials and compute energy.
dftsolve.F:         if (rpcc.gt.1e-12.and.ipsp.ne.0) then
dftsolve.F:            enddo
dftsolve.F:            enddo
dftsolve.F:            enddo
dftsolve.F:         endif
dftsolve.F:            ebs = ebs + wnl(m) * en(m)
dftsolve.F:         enddo
dftsolve.F:c     Section 6:  Mix potentials
dftsolve.F:         enddo
dftsolve.F:         enddo
dftsolve.F:            enddo
dftsolve.F:         enddo
dftsolve.F:         if (niter.eq.1) then
dftsolve.F:         endif
dftsolve.F:c     Section 7:  predict trial eigenvals use 1st order perturb theory.
dftsolve.F:         enddo
dftsolve.F:            if (m.le.ncore) then
dftsolve.F:            endif
dftsolve.F:            if (ifc.eq.0.and.ibound.eq.1) then
dftsolve.F:               if (irel.eq.0) then
dftsolve.F:                  enddo
dftsolve.F:                  enddo
dftsolve.F:               endif
dftsolve.F:               if(nmax(m).le.10) then
dftsolve.F:               endif
dftsolve.F:               en(m) = en(m) + xl
dftsolve.F:               if (en(m).ge.0.0) then
dftsolve.F:                  enddo
dftsolve.F:                  en(m) = vmin * 0.5d0
dftsolve.F:                  write (7,505) nlm(m),en(m)               
dftsolve.F:                  if (en(m).ne.en(m)) then
dftsolve.F:                  endif
dftsolve.F:               endif
dftsolve.F:            endif
dftsolve.F:         enddo
dftsolve.F:      enddo
dftsolve.F: 505  format(1x,'!WARNING! positive eigenvalue predicted',
dftsolve.F:      if (ilogder.eq.1) then
dftsolve.F:         if (ipsp.eq.0) then
dftsolve.F:               enddo
dftsolve.F:               enddo
dftsolve.F:            enddo
dftsolve.F:         endif
dftsolve.F:         if (ipsp.eq.1) then
dftsolve.F:            if (inl.eq.0) then
dftsolve.F:                  enddo
dftsolve.F:                  enddo
dftsolve.F:               enddo
dftsolve.F:               enddo
dftsolve.F:            endif
dftsolve.F:         endif
dftsolve.F:      endif
dftsolve.F:         if (irel.eq.0) then
dftsolve.F:               if (abs(rnl(k,i)).gt.1e-10) then
dftsolve.F:                  if (rnl(k,i).lt.0.0) then
dftsolve.F:                     enddo
dftsolve.F:                  endif
dftsolve.F:               endif
dftsolve.F:            enddo
dftsolve.F:c            if (ibd(i-ncore).eq.0) then
dftsolve.F:c               enddo
dftsolve.F:c            endif
dftsolve.F:               if (abs(rnla(k,i)).gt.1e-10) then
dftsolve.F:                  if (rnla(k,i).lt.0.0) then
dftsolve.F:                     enddo
dftsolve.F:                  endif
dftsolve.F:               endif
dftsolve.F:            enddo
dftsolve.F:               if (abs(rnlb(k,i)).gt.1e-10) then
dftsolve.F:                  if (rnlb(k,i).lt.0.0) then
dftsolve.F:                     enddo
dftsolve.F:                  endif
dftsolve.F:               endif
dftsolve.F:            enddo
dftsolve.F:         endif
dftsolve.F:      enddo
dftsolve.F:c     compute valence density 
dftsolve.F:      enddo
dftsolve.F:         if (irel.eq.0) then
dftsolve.F:            enddo
dftsolve.F:            enddo
dftsolve.F:         endif
dftsolve.F:      enddo
dftsolve.F:c     compute core density
dftsolve.F:      if (ipsp.eq.0) then
dftsolve.F:         enddo
dftsolve.F:            if (irel.eq.0) then
dftsolve.F:               enddo
dftsolve.F:               enddo
dftsolve.F:            endif
dftsolve.F:         enddo
dftsolve.F:      endif
dftsolve.F:c     loop over valence
dftsolve.F:      if (irel.eq.0) then
dftsolve.F:            enddo
dftsolve.F:            if (ibd(ic).eq.1) then
dftsolve.F:c     special treatment for unbound states (norm from 0 to rc is 1)
dftsolve.F:               enddo
dftsolve.F:               enddo
dftsolve.F:            endif
dftsolve.F:         enddo                     
dftsolve.F:            enddo
dftsolve.F:            if (ibd(ic).eq.1) then
dftsolve.F:               enddo
dftsolve.F:               enddo
dftsolve.F:            endif
dftsolve.F:         enddo
dftsolve.F:      endif
dftsolve.F:c      if (ipsp.eq.0) then
dftsolve.F:c            enddo
dftsolve.F:c         enddo
dftsolve.F:c      endif
dftsolve.F:c        if (rnla(maxim,i).lt.0.0) then
dftsolve.F:c          enddo
dftsolve.F:c        endif
dftsolve.F:c      enddo
dftsolve.F:      if (irel.eq.0) then
dftsolve.F:            if (ibd(ic).ne.0) then
dftsolve.F:                  if (rnl(j,i).lt.rnl(j+1,i)) then
dftsolve.F:                  endif
dftsolve.F:               enddo
dftsolve.F:            endif
dftsolve.F:         enddo
dftsolve.F:            if (ibd(i-ncore).ne.0) then
dftsolve.F:                  if (rnla(j,i).lt.rnla(j+1,i)) then
dftsolve.F:     $                    and.(abs(rnla(j,i)).gt.1e-6)) then
dftsolve.F:                     endif
dftsolve.F:                  endif
dftsolve.F:               enddo
dftsolve.F:            endif
dftsolve.F:         enddo
dftsolve.F:      endif
dftsolve.F:      if (niter.eq.1) then
dftsolve.F:      endif
dftsolve.F:         if (irel.eq.0) then
dftsolve.F:            write (7,9223) nlm(i),wnl(i),en(i)
dftsolve.F:            if (lo(i).eq.0) then
dftsolve.F:               write (7,9523) nlm(i),wnl(i),en(i)
dftsolve.F:               if (so(i).lt.0) then
dftsolve.F:                  write (7,9323) nlm(i),wnl(i),en(i)
dftsolve.F:                  write (7,9423) nlm(i),wnl(i),en(i)
dftsolve.F:               endif
dftsolve.F:            endif
dftsolve.F:         endif
dftsolve.F:      enddo
dftsolve.F:         if (irel.eq.0) then
dftsolve.F:            if (ibd(ic).ne.0) then
dftsolve.F:               write (7,9223) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
dftsolve.F:               write (7,9224) nlm(i),wnl(i),en(i)
dftsolve.F:            endif
dftsolve.F:            if (lo(i).eq.0) then
dftsolve.F:               if (ibd(ic).ne.0) then
dftsolve.F:                  write (7,9523) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
dftsolve.F:                  write (7,9524) nlm(i),wnl(i),en(i)
dftsolve.F:               endif
dftsolve.F:               if (so(i).lt.0) then
dftsolve.F:                  if (ibd(ic).ne.0) then
dftsolve.F:                     write (7,9323) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
dftsolve.F:                     write (7,9324) nlm(i),wnl(i),en(i)
dftsolve.F:                  endif
dftsolve.F:                  if (ibd(ic).ne.0) then
dftsolve.F:                     write (7,9423) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
dftsolve.F:                     write (7,9424) nlm(i),wnl(i),en(i)
dftsolve.F:                  endif
dftsolve.F:               endif
dftsolve.F:            endif
dftsolve.F:         endif
dftsolve.F:      enddo
dftsolve.F:      if (ipsp.ne.0.and.rpcc.gt.1e-12) then
dftsolve.F:      endif
dftsolve.F: 700  format(1x,'Converged in 1 iteration (probably reference state)')
dftsolve.F: 9222 format(3x,'Orbital',4x,'Filling',7x,'Eigenvalues',4x,
dftsolve.F:      if (inl.ne.0) then
dftsolve.F:      endif
dftsolve.F:      write(7,*) " !!ERROR!! Could not find self-consistent solution!"
dftsolve.F:     +     ' number of valence orbitals =',i3,/,
dftsolve.F:      end
dsordf.F:c it under the terms of the GNU General Public License as published by
dsordf.F:c the Free Software Foundation; either version 2 of the License, or
dsordf.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
dsordf.F:c GNU General Public License for more details.
dsordf.F:c You should have received a copy of the GNU General Public License
dsordf.F:c                  cg(l,i)  large component of the orbital i                    
dsordf.F:c                  cp(l,j)  small component of the orbital j                    
dsordf.F:c        the development limits at the origin (used for calculation             
dsordf.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
dsordf.F:      dimension hg(npdm),chg(10)                                                 
dsordf.F:      dimension bgi(10),bgj(10),bpi(10),bpj(10)                                 
dsordf.F:      end                                                                       
etotal.F:c it under the terms of the GNU General Public License as published by
etotal.F:c the Free Software Foundation; either version 2 of the License, or
etotal.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
etotal.F:c GNU General Public License for more details.
etotal.F:c You should have received a copy of the GNU General Public License
etotal.F:c en one-electron energies                                                      
etotal.F:c akeato angular coefficient for integrals  fk, for the                         
etotal.F:c integrals fk(i;i) gives angular coefficients multiplied by 2                  
etotal.F:c bkeato angular coefficient for integrals  gk                                  
etotal.F:c coul ener(1) direct coulomb interaction                                       
etotal.F:c ech  ener(2) exchange coulomb interaction                                     
etotal.F:c bkmrdf is a programm to calculate angular coefficients                        
etotal.F:c ema ener(3) magnetic energy                                                   
etotal.F:c ere ener(4) retardation term                                                  
etotal.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
etotal.F:      dimension kap(N0)
etotal.F:      dimension mk(12),ener(4)                                                  
etotal.F:      dimension cer(17),mbi(9),mii(9),mjj(9)                                    
etotal.F: 10   ener(i)=0.0d 00                                                           
etotal.F:            ener(1)=ener(1)+cer(iv)*akeato(i,j,k)/a                             
etotal.F:c            write(7,*) 'hart', i,j,k,kap(j),iv,ener(1),
etotal.F:      if (norb.gt.1) then                                                       
etotal.F:             ener(2) = ener(2) -cer(iv)*bkeato(i,j,k)                           
etotal.F:      endif                                                                     
etotal.F:            ener(3)=ener(3)+(cmag(1)+cmag(2)+cmag(3))*cer(ik)*                  
etotal.F:      if (norb.gt.1) then                                                       
etotal.F:               ener(3) =ener(3) +cmag(i)*cer(i)*b                               
etotal.F: 185           ener(4) =ener(4) +cret(i)*cer(i)*b                               
etotal.F:      endif                                                                     
etotal.F:c       total   energy                                                          
etotal.F:c      eatom = -(ener(1)+ener(2))
etotal.F:c      eatom = -(ener(1)+ener(2))+ener(3)+ener(4)                                
etotal.F:      eh=ener(1)
etotal.F:      ex=ener(2)
etotal.F: 212     eatom = eatom + en(j)*wnl(j)                                          
etotal.F:c         if (iprint .ge. 1) write(16,'(a4,1pd18.7)') iner(i),ener(i)            
etotal.F:c         write(7,'(a4,1pd18.7)') iner(i),ener(i)                             
etotal.F:      end                                                                       
etotal.F:c     angular coefficients for the breit term                                   
etotal.F:c coefficients for magnetic interaction  are in cmag                            
etotal.F:c      common/ratom1/xnel(N0),en(N0),scc(N0),scw(N0),sce(N0),                    
etotal.F:      dimension kap(n0)
etotal.F:      end                                                                       
etotal.F:c      common/ratom1/xnel(N0),en(N0),scc(N0),scw(N0),sce(N0),                    
etotal.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
etotal.F:      dimension kap(n0)
etotal.F:      if (j.eq.i) then                                                          
etotal.F:      endif                                                                     
etotal.F:      end                                                                       
excorr.F:c it under the terms of the GNU General Public License as published by
excorr.F:c the Free Software Foundation; either version 2 of the License, or
excorr.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
excorr.F:c GNU General Public License for more details.
excorr.F:c You should have received a copy of the GNU General Public License
excorr.F:      dimension rsatom(npdm),rvxc(npdm),rexc(npdm)
excorr.F:      dimension agde(npdm),agdc(npdm),ggagde(npdm),ggagdc(npdm),
excorr.F:     $     rlape(npdm),rlapc(npdm),dens(npdm),
excorr.F:      dimension bb(3,3),vcc(3)
excorr.F:      dimension ipvt(3)
excorr.F:c     ictype=1  : smoothing at origin is done by polynomial fit when descreening ONLY
excorr.F:      if ((ixc.gt.6).or.(ixc.lt.0)) then
excorr.F:      endif
excorr.F:         dens(i) = rsatom(i)/(4.0*pi*r(i)*r(i))
excorr.F:         if (iset.eq.0) then
excorr.F:            if (dens(i).lt.1e-16.and.r(i).gt.5.d0) then
excorr.F:            endif
excorr.F:         endif
excorr.F:      if (ixc.ge.2.and.ixc.lt.6) then
excorr.F:         call grad(dens,agde,
excorr.F:         if (irelxc.eq.1) then
excorr.F:         endif
excorr.F:      endif
excorr.F:c     this if-then if it is negative anyway
excorr.F:         if (r(i).lt.exccut.and.exccut.gt.1e-10) then
excorr.F:         endif
excorr.F:         if (ixc.eq.1.or.ixc.eq.0.or.ixc.eq.6) then
excorr.F:            if (irelxc.eq.1) then
excorr.F:            endif
excorr.F:         endif
excorr.F:         if (ixc.ge.2.and.ixc.lt.6) then
excorr.F:            if (ixc.eq.2) then
excorr.F:            endif
excorr.F:            if(ixc.eq.3) then
excorr.F:            endif
excorr.F:            if(ixc.eq.4) then
excorr.F:            endif
excorr.F:            if (ixc.eq.5) then
excorr.F:            endif
excorr.F:            if (irelxc.eq.1) then
excorr.F:               if (r(i).lt.1e-4) then
excorr.F:               endif
excorr.F:            endif
excorr.F:         endif
excorr.F:         if (ixc.eq.0) then
excorr.F:         endif
excorr.F:         if (ixc.eq.6) then
excorr.F:            call corvwn(rs,ec,vc,dens(i))
excorr.F:         endif
excorr.F:         if (ixc.eq.1) then
excorr.F:         endif
excorr.F:         if (ixc.eq.2.or.ixc.eq.4) then
excorr.F:         endif            
excorr.F:         if (ixc.eq.3) then
excorr.F:         endif            
excorr.F:         if (ixc.eq.5) then
excorr.F:         endif
excorr.F:      enddo
excorr.F:      if (ictype.eq.1) then
excorr.F:            if (r(i).gt.-exccut) then 
excorr.F:            endif
excorr.F:         enddo
excorr.F:         enddo
excorr.F:      endif
excorr.F:      end
excorr.F:      subroutine grad(dens,agde,ggagde,rlape,agdc,ggagdc,
excorr.F:c     External (shared between C and Fortran) common blocks
excorr.F:      dimension dens(npdm),agrd(npdm),grd(npdm)
excorr.F:      dimension agde(npdm),agdc(npdm),ggagde(npdm),ggagdc(npdm),
excorr.F:c     prepare the various gradient terms
excorr.F:      enddo
excorr.F:         dens(i)=0.0
excorr.F:      enddo
excorr.F:         fk=(3*pi2*dens(i))**o3
excorr.F:         grd(i)=(dens(i+1)-dens(i-1))/2.0
excorr.F:         rgrd(i)=r(i)*grd(i)+dens(i)
excorr.F:         agde(i)=(1.0/(2*fk*dens(i))) * agrd(i)
excorr.F:         agdc(i)=(1.0/(2*fs*dens(i))) * agrd(i)
excorr.F:      enddo
excorr.F:         fk=(3*pi2*dens(i))**o3
excorr.F:         ggagde(i)=ggagd * (grd(i)/(dens(i) 
excorr.F:     $        * dens(i)*(2*fk)**3))
excorr.F:         ggagdc(i)=ggagd * (grd(i)/(dens(i) 
excorr.F:     $        * dens(i)*(2*fs)**3))
excorr.F:         rlape(i)=rlap/(dens(i)*(2*fk)**2)
excorr.F:         rlapc(i)=rlap/(dens(i)*(2*fs)**2)
excorr.F:      enddo
excorr.F:         fkplus=(3*pi2*dens(i+1))**o3
excorr.F:         fkminus=(3*pi2*dens(i-1))**o3
excorr.F:         fk=(3*pi2*dens(i))**o3
excorr.F:         splus=abs(dens(i+2)-dens(i))/(4*h*r(i+1)*dens(i+1)*fkplus)
excorr.F:         sminus=abs(dens(i)-dens(i-2))/(4*h*r(i-1)*dens(i-1)*fkminus)
excorr.F:         deln=(dens(i+1)-dens(i-1))/(2*h*r(i))
excorr.F:         tau(i)=dels2*deln/(4*dens(i)*fk**2)
excorr.F:      enddo
excorr.F:      end
fdrirk.F:c it under the terms of the GNU General Public License as published by
fdrirk.F:c the Free Software Foundation; either version 2 of the License, or
fdrirk.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
fdrirk.F:c GNU General Public License for more details.
fdrirk.F:c You should have received a copy of the GNU General Public License
fdrirk.F:c                  cg (cp) large (small) componenents of the orbitales          
fdrirk.F:      dimension hg(npdm),kap(n0)                                                         
fdrirk.F:      end                                                                       
getpcc.F:c it under the terms of the GNU General Public License as published by
getpcc.F:c the Free Software Foundation; either version 2 of the License, or
getpcc.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
getpcc.F:c GNU General Public License for more details.
getpcc.F:c You should have received a copy of the GNU General Public License
getpcc.F:c     External (shared between C and Fortran) common blocks
getpcc.F:      common /filenames/ file_log
getpcc.F:      dimension rdensity(npdm)
getpcc.F:      open(unit=7,file=file_log,form='formatted',access='append')
getpcc.F:         rdensity(i)=rscore(i)/(r(i)*r(i))
getpcc.F:      enddo
getpcc.F:      if (ipccmeth.eq.0) then
getpcc.F:         call LFC(rdensity,rscore)
getpcc.F:         call fhipcc(rdensity,rscore,iexit)
getpcc.F:      endif
getpcc.F:         enddo
getpcc.F:         enddo
getpcc.F:      enddo
getpcc.F:      enddo
getpcc.F:      end
getpcc.F:c     External (shared between C and Fortran) common blocks
getpcc.F:      common /filenames/ file_log
getpcc.F:      dimension rleft(n),right(n),b(n)
getpcc.F:      dimension rcore(npdm),rpcore(npdm)
getpcc.F:c  get the charge density and the gradient of the charge density 
getpcc.F:      if (rconst.gt.0) then
getpcc.F:            if  (eps.gt.0) then
getpcc.F:            endif
getpcc.F:         enddo        
getpcc.F:      endif
getpcc.F:      if (rconst.lt.0) then
getpcc.F:            if  (eps.gt.0) then
getpcc.F:            endif
getpcc.F:         enddo        
getpcc.F:      endif
getpcc.F:      if (rconst.eq.0) then
getpcc.F:       endif
getpcc.F:      enddo
getpcc.F:      enddo
getpcc.F:      end
getpcc.F:c     External (shared between C and Fortran) common blocks
getpcc.F:      dimension rd1(npdm),rd2(npdm)
getpcc.F:      dimension rcore(npdm),rpcore(npdm)
getpcc.F:      dimension b(4),a(4,4)
getpcc.F:      dimension ipvt(4)
getpcc.F:c     get the 1st and 2nd deriv. of the AE core density
getpcc.F:         enddo
getpcc.F:         enddo
getpcc.F:      enddo
getpcc.F:         c0=1.8*rpden(r(i),c0,c3,c4,c5,c6)
getpcc.F:         if(info .ne. 0) then
getpcc.F:         endif
getpcc.F:            if(rpden(r(i),c0,c3,c4,c5,c6) .gt. c0) goto 911
getpcc.F:         enddo
getpcc.F:      enddo
getpcc.F:         rpcore(i)=rpden(r(i),c0,c3,c4,c5,c6)
getpcc.F:      enddo
getpcc.F:      enddo
getpcc.F:      end
getpcc.F:      double precision function rpden(rv,c0,c3,c4,c5,c6)
getpcc.F:      rpden=c0 + c3*rv3 + c4*rv4 + c5*rv5 + c6*rv6
getpcc.F:      end
ghostnl.F:c it under the terms of the GNU General Public License as published by
ghostnl.F:c the Free Software Foundation; either version 2 of the License, or
ghostnl.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
ghostnl.F:c GNU General Public License for more details.
ghostnl.F:c You should have received a copy of the GNU General Public License
ghostnl.F:c     of the local potential.
ghostnl.F:c     For nonlocal components, we calculate elkb.  The ghost theorem of
ghostnl.F:c     For elkb>0, and eat>e1l the potential has a ghost below eat.
ghostnl.F:c     For elkb<0, and eat>el0 the potential has a ghost below eat.
ghostnl.F:c     Here eat is the reference eigenvalue of the nonlocal angular momentum.
ghostnl.F:c     External (shared between C and Fortran) common blocks
ghostnl.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
ghostnl.F:      common /box/ iboxstart(n0),iboxend(n0),boxheight(n0),numbox
ghostnl.F:      dimension rvloc(npdm)
ghostnl.F:      dimension fr(npdm),p(npdm),gghost(npdm)
ghostnl.F:      dimension el0(n0),el1(n0),isemi(n0)
ghostnl.F:c      if (ibd(iloc).eq.0) then
ghostnl.F:c         write(7,*) " !WARNING!   when the local pot is unbound!"
ghostnl.F:c         write(7,*) "Please change your choice of local potential, = "
ghostnl.F:c      endif
ghostnl.F:      enddo
ghostnl.F:      enddo
ghostnl.F:          if (l2.eq.l.and.n2.ne.n) then
ghostnl.F:          endif
ghostnl.F:        enddo
ghostnl.F:      enddo
ghostnl.F:        if (ibd(k).eq.0) then
ghostnl.F:        endif
ghostnl.F:        ee = en(k)
ghostnl.F:        if (iterm0.eq.1) then
ghostnl.F:        endif
ghostnl.F:        if (iterm1.eq.1) then
ghostnl.F:        endif
ghostnl.F:        enddo
ghostnl.F:        xden = tov
ghostnl.F:        enddo
ghostnl.F:        if (xden.ne.0) then
ghostnl.F:           elkb = xnum/xden
ghostnl.F:           write(7,9103) el0(k),el1(k),en(k)           
ghostnl.F:           if (elkb.gt.0.0) then
ghostnl.F:c     if (iterm1.eq.0.and.iterm0.eq.0) then
ghostnl.F:              if (en(k).lt.el1(k).and.en(k).gt.el0(k)) then
ghostnl.F:                 write(7,9020) n,xc(l),en(k),el1(k)
ghostnl.F:              endif
ghostnl.F:c     endif
ghostnl.F:c     if (iterm0.eq.0) then
ghostnl.F:              if (en(k).lt.el0(k)) then
ghostnl.F:                 write(7,9020) n,xc(l),en(k),el0(k)
ghostnl.F:              endif
ghostnl.F:           endif
ghostnl.F:c     endif
ghostnl.F:     $          '...seems like this angular momentum is the local part!'
ghostnl.F:        endif
ghostnl.F:      enddo
ghostnl.F:      if (ighost.eq.0) then
ghostnl.F:         if (numbox.gt.0) then
ghostnl.F:            write (7,*) 'No ghosts present for designed local pot'
ghostnl.F:            write (7,*) 'No ghosts present for local potential'
ghostnl.F:         endif
ghostnl.F:         if(ighost.eq.-1) then
ghostnl.F:         endif
ghostnl.F:      endif
ghostnl.F:     $     " 1) the choice of local potential",/,
ghostnl.F:     $     " 3) the reference configuration")
ghostnl.F: 9400 format(1x,'No ghosts for local potential: ',i1,a1)
ghostnl.F: 9111 format(1x,'KB energy : ',f10.6,2x
ghostnl.F:     $     ,'KB strength: ',f10.6,2x,'KB cosine: ',f10.6,2x)
ghostnl.F:     $     ' of local potential.  Setting e=0.0')
ghostnl.F:     $     ' of local potential.  Setting e=0.0')
ghostnl.F:     $     "Must have two bound states for local pot when Ekb>0")
ghostnl.F:      end
hfcoef.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
hfcoef.F:c it under the terms of the GNU General Public License as published by
hfcoef.F:c the Free Software Foundation; either version 2 of the License, or
hfcoef.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
hfcoef.F:c GNU General Public License for more details.
hfcoef.F:c You should have received a copy of the GNU General Public License
hfcoef.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfcoef.F:*  *****  average interactions for equivalent electrons
hfcoef.F:*  ***** average interactions for non-equivalent electrons
hfcoef.F:            if ( i .ne. j) then
hfcoef.F:            end if
hfcoef.F:               if (k .eq. 0) then
hfcoef.F:               else if (i .eq. j) then
hfcoef.F:               end if
hfcoef.F:            enddo
hfcoef.F:            if (i .ne. j) then
hfcoef.F:               enddo
hfcoef.F:            endif
hfcoef.F:         enddo
hfcoef.F:      enddo
hfcoef.F:      end
hfcoef.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfcoef.F:      if (i.gt.ncore .and. j.gt.ncore) then
hfcoef.F:      else if (i.eq.j) then
hfcoef.F:         if (k.eq.0) then
hfcoef.F:         end if
hfcoef.F:      else if (k.eq.0) then
hfcoef.F:      endif
hfcoef.F:      end
hfcoef.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfcoef.F:      if (i.eq.j) then
hfcoef.F:      else if (i.gt.ncore .and. j.gt.ncore) then
hfcoef.F:      endif
hfcoef.F:      end
hfcoef.F:      if (l .le. 4) then
hfcoef.F:      endif
hfcoef.F:      end
hfcoef.F:      if (l .le. lp) then
hfcoef.F:      end if
hfcoef.F:      if ( l2 .le. 4) then
hfcoef.F:      endif
hfcoef.F:      end
hfcoef_rel.F:c it under the terms of the GNU General Public License as published by
hfcoef_rel.F:c the Free Software Foundation; either version 2 of the License, or
hfcoef_rel.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
hfcoef_rel.F:c GNU General Public License for more details.
hfcoef_rel.F:c You should have received a copy of the GNU General Public License
hfcoef_rel.F:c     determine the self-consistent solution
hfcoef_rel.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfcoef_rel.F:      dimension ka(n0)
hfcoef_rel.F:            enddo
hfcoef_rel.F:         enddo
hfcoef_rel.F:      enddo
hfcoef_rel.F:         if (lo(i).ne.0) then
hfcoef_rel.F:         endif
hfcoef_rel.F:            if (lo(j).ne.0) then
hfcoef_rel.F:            endif
hfcoef_rel.F:            if (j.eq.i) then
hfcoef_rel.F:            endif
hfcoef_rel.F:            if (j.ne.i) then
hfcoef_rel.F:            endif
hfcoef_rel.F:            if (j.eq.i) then                                                    
hfcoef_rel.F:            endif                                                               
hfcoef_rel.F:            enddo
hfcoef_rel.F:         enddo
hfcoef_rel.F:      enddo
hfcoef_rel.F:      end
hfde.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
hfde.F:c it under the terms of the GNU General Public License as published by
hfde.F:c the Free Software Foundation; either version 2 of the License, or
hfde.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
hfde.F:c GNU General Public License for more details.
hfde.F:c You should have received a copy of the GNU General Public License
hfde.F:c     External (shared between C and Fortran) common blocks
hfde.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfde.F:      dimension p(npdm),dpm(n0),rsatom(npdm)
hfde.F:      if (norb.eq.1) then
hfde.F:      endif
hfde.F:      enddo
hfde.F:      if (imeth.eq.1) then
hfde.F:     $        gt.0.20d0) then
hfde.F:         endif
hfde.F:      endif
hfde.F:      if (ipr.ne.m) then
hfde.F:         if (ed1*ed2.gt.0) then
hfde.F:         endif
hfde.F:      endif
hfde.F:      !Here, dp is the difference between previous and current radial
hfde.F:      enddo
hfde.F:      enddo
hfde.F:      if (wnl(m).lt.1e-6) then
hfde.F:      endif
hfde.F:         if (abs(e(m,j)).ne.0.d0.and.m.ne.j) then
hfde.F:            if (dpm(j).lt.dsqrt(wnl(j))*dpw) then
hfde.F:               enddo
hfde.F:            endif
hfde.F:         endif
hfde.F:      enddo
hfde.F:      if (abs(rx).gt.0) then
hfde.F:         enddo
hfde.F:      endif
hfde.F: 687  if (dabs(rnlp(jjset,m)).lt.1e-15) then
hfde.F:      endif
hfde.F:      en(m)=e(m,m)
hfde.F:      if(ipr.eq.m) then
hfde.F:      endif
hfde.F:      enddo
hfde.F:      if ( fail ) then
hfde.F:      endif
hfde.F:      end
hfenergy.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
hfenergy.F:c it under the terms of the GNU General Public License as published by
hfenergy.F:c the Free Software Foundation; either version 2 of the License, or
hfenergy.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
hfenergy.F:c GNU General Public License for more details.
hfenergy.F:c You should have received a copy of the GNU General Public License
hfenergy.F:      subroutine hfenergy(ipsp,etotal,ehart,exx,ekn)
hfenergy.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfenergy.F:      dimension rm1(n0),ek(n0),yk(npdm)
hfenergy.F:         if (ipsp.eq.0) then
hfenergy.F:            enddo
hfenergy.F:         endif
hfenergy.F:      enddo
hfenergy.F:            enddo
hfenergy.F:         enddo
hfenergy.F:            enddo
hfenergy.F:         enddo
hfenergy.F:      enddo
hfenergy.F:      end
hfint.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
hfint.F:c it under the terms of the GNU General Public License as published by
hfint.F:c the Free Software Foundation; either version 2 of the License, or
hfint.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
hfint.F:c GNU General Public License for more details.
hfint.F:c You should have received a copy of the GNU General Public License
hfint.F:c     External (shared between C and Fortran) common blocks
hfint.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfint.F:      dimension p(npdm), yk(npdm)
hfint.F:      dimension x(npdm)
hfint.F:      dimension xz(npdm),w(npdm),p1(npdm),p2(npdm)
hfint.F:      dimension yr(npdm),hq(npdm),xx(npdm)
hfint.F:      enddo
hfint.F:      enddo
hfint.F:      enddo
hfint.F:      enddo
hfint.F:      if (ipsp.eq.0) then
hfint.F:      endif
hfint.F:      cden=0.d0
hfint.F:         cden=cden+rnlp(j,m)*ddum
hfint.F:      enddo
hfint.F:      ed=fl/(cden*ch)
hfint.F:      if (ed.lt.em) then
hfint.F:         if (ipsp.eq.0) then
hfint.F:         endif
hfint.F:         enddo
hfint.F:      endif
hfint.F:      if (10.d0*ed.gt.eu) then
hfint.F:      endif
hfint.F:      enddo
hfint.F:         if (ipsp.eq.0) then
hfint.F:         endif
hfint.F:      enddo
hfint.F:      enddo
hfint.F:      enddo
hfint.F:      if (imeth.eq.2) then
hfint.F:         enddo
hfint.F:         enddo
hfint.F:         enddo
hfint.F:      endif
hfint.F:      enddo
hfint.F:      end
hfint.F:*       given two starting values, pde(1) and pde(2), values of pde(j),
hfint.F:*   using the discretization  of  eq.  (6-27 )  with  the  difference
hfint.F:*   correction.  with pde(nj) given, the tail procedure is applied to
hfint.F:*   and delta is the difference between  pde(nj+1)  for  outward  and
hfint.F:      dimension pdef(npdm),f(npdm),a(npdm),d(npdm),yr(npdm)
hfint.F:      equivalence (g,g3)
hfint.F:      enddo
hfint.F:      if (k .ge. (np)-1 .or. m .eq. np) then 
hfint.F:      endif
hfint.F:      enddo
hfint.F:      enddo
hfint.F:*  *****  set delta = difference of the two solutions at nj+1
hfint.F:      end
hfmethd.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
hfmethd.F:c it under the terms of the GNU General Public License as published by
hfmethd.F:c the Free Software Foundation; either version 2 of the License, or
hfmethd.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
hfmethd.F:c GNU General Public License for more details.
hfmethd.F:c You should have received a copy of the GNU General Public License
hfmethd.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfmethd.F:      dimension p(npdm)
hfmethd.F:      if (ipsp.eq.0) then
hfmethd.F:      endif
hfmethd.F:      enddo
hfmethd.F:      enddo
hfmethd.F:      if ((ncc-node).gt.0) then
hfmethd.F:         if (p(mm).lt.0.d0) then
hfmethd.F:         endif
hfmethd.F:         if (dabs(fm - ed) .lt. 0.00001d0) then
hfmethd.F:         endif
hfmethd.F:      elseif((ncc-node).lt.0) then
hfmethd.F:         enddo
hfmethd.F:      endif
hfmethd.F:      en(m)=e(m,m)
hfmethd.F:      end
hfsolve.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
hfsolve.F:c it under the terms of the GNU General Public License as published by
hfsolve.F:c the Free Software Foundation; either version 2 of the License, or
hfsolve.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
hfsolve.F:c GNU General Public License for more details.
hfsolve.F:c You should have received a copy of the GNU General Public License
hfsolve.F:c     determine the self-consistent solution
hfsolve.F:c     External (shared between C and Fortran) common blocks
hfsolve.F:      common /filenames/ file_log
hfsolve.F:      common /box/ iboxstart(n0),iboxend(n0),boxheight(n0),numbox
hfsolve.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfsolve.F:      dimension eold(n0)
hfsolve.F:      dimension rsatom(npdm),rsold(npdm)
hfsolve.F:      dimension wavea(npdm),icarray(30)
hfsolve.F:      dimension x(npdm),yr(npdm),fr(npdm),fr2(npdm)
hfsolve.F:      dimension lcount(10)
hfsolve.F:      open(unit=7,file=file_log,form='formatted',access='append')
hfsolve.F:      iflag=0  ! comment by JY: this is a dummy variable 
hfsolve.F:c     EJW - adding this to keep allow to pick a hyrdogenic wavefunction 
hfsolve.F:      enddo
hfsolve.F:         en(i)=-en(i)
hfsolve.F:         enddo
hfsolve.F:         e(i,i)=en(i)
hfsolve.F:         enddo
hfsolve.F:      enddo
hfsolve.F:      if (ipsp.eq.0) then
hfsolve.F:            enddo
hfsolve.F:            e(j,j)=-en(j)
hfsolve.F:            enddo
hfsolve.F:         enddo
hfsolve.F:            enddo
hfsolve.F:         enddo
hfsolve.F:      endif
hfsolve.F:      enddo
hfsolve.F:      enddo
hfsolve.F:      if (ipsp.eq.0) then
hfsolve.F:            enddo
hfsolve.F:         enddo
hfsolve.F:            if (lcount(lo(i)+1).gt.1) then
hfsolve.F:               enddo
hfsolve.F:            endif
hfsolve.F:         enddo
hfsolve.F:      endif
hfsolve.F:            if (e(i,j).gt.0.d0) then
hfsolve.F:               if (abs(rx).gt.1e-8) then
hfsolve.F:                  enddo
hfsolve.F:               endif
hfsolve.F:            endif
hfsolve.F:         enddo
hfsolve.F:      enddo
hfsolve.F:C          if (ipsp.ne.0) then
hfsolve.F:C                enddo
hfsolve.F:C             enddo
hfsolve.F:C          endif
hfsolve.F:         enddo
hfsolve.F:            eold(m)=en(m)
hfsolve.F:            edif = abs((en(m) - eold(m))/eold(m))
hfsolve.F:            eold(m) = en(m)
hfsolve.F:         enddo
hfsolve.F:            eold(m)=en(m)
hfsolve.F:               edif = abs((en(m) - eold(m))/eold(m))
hfsolve.F:               eold(m) = en(m)
hfsolve.F:            enddo
hfsolve.F:         enddo
hfsolve.F:            ebs = ebs + wnl(m) * en(m)
hfsolve.F:         enddo
hfsolve.F: 8       format(6x,'least self-consistent function is ',i3,
hfsolve.F:         call hfenergy(ipsp,etot,ehart,exx,ekn)      
hfsolve.F:         if (iprint.gt.0) then
hfsolve.F:            if (niter.eq.1) then
hfsolve.F:            endif
hfsolve.F:         endif
hfsolve.F:      enddo
hfsolve.F:      if (iprint.gt.0)  then
hfsolve.F:      endif
hfsolve.F:c            if (nloc.ne.i) then
hfsolve.F:c               enddo
hfsolve.F:c               xden = tov
hfsolve.F:c               enddo
hfsolve.F:c               elkb = xnum/xden
hfsolve.F:c 9111          format(2i5,1x,'KB energy : ',f10.6,2x
hfsolve.F:c     $              ,'KB strength: ',f10.6,2x,'KB cosine: ',f10.6,2x)
hfsolve.F:c            endif
hfsolve.F:c         enddo
hfsolve.F:c      enddo
hfsolve.F:      if (ipsp.eq.33) then
hfsolve.F:         write(7,*) 'E=',-en(m)
hfsolve.F:         enddo
hfsolve.F:            write(7,*) 'E=',-en(m)
hfsolve.F:            write(7,*) 'E=',-en(m)
hfsolve.F:         enddo
hfsolve.F:      endif
hfsolve.F:c      if (ipsp.ne.0) then
hfsolve.F:c            enddo
hfsolve.F:c         enddo
hfsolve.F:c      endif
hfsolve.F:      if (ipsp.eq.0) then
hfsolve.F:     $              and.(r(j).gt.15.0)) then
hfsolve.F:               endif
hfsolve.F:            enddo
hfsolve.F:            enddo
hfsolve.F:         enddo
hfsolve.F:      endif
hfsolve.F:         enddo
hfsolve.F:         en(i)=-en(i)
hfsolve.F:      enddo
hfsolve.F:      enddo
hfsolve.F:         enddo
hfsolve.F:      enddo
hfsolve.F:      if (ipsp.eq.0) then
hfsolve.F:         open(unit=33,file="vcore",form="formatted")
hfsolve.F:         enddo
hfsolve.F:      endif
hfsolve.F:            if (abs(rnlp(j,i)).gt.1e-6) then
hfsolve.F:            endif
hfsolve.F:         enddo
hfsolve.F:         if (rnlp(nmax(i)-1,i).lt.0.0) then
hfsolve.F:            enddo
hfsolve.F:         endif
hfsolve.F:      enddo
hfsolve.F:c     compute valence density 
hfsolve.F:      enddo
hfsolve.F:         enddo
hfsolve.F:      enddo
hfsolve.F:c     compute core density
hfsolve.F:      if (ipsp.eq.0) then
hfsolve.F:         enddo
hfsolve.F:            enddo
hfsolve.F:         enddo
hfsolve.F:      endif
hfsolve.F:c     loop over valence
hfsolve.F:         enddo
hfsolve.F:      enddo
hfsolve.F:     $           and.(abs(rnlp(j,i)).gt.1e-6)) then
hfsolve.F:            endif
hfsolve.F:         enddo
hfsolve.F:      enddo
hfsolve.F:      if (niter.eq.1) then
hfsolve.F:      endif
hfsolve.F:         if (iprint.gt.0)  write (7,9223) nlm(i),wnl(i),en(i)
hfsolve.F:      enddo
hfsolve.F:     $        en(i),rnorm(i),rvap(i)
hfsolve.F:      enddo
hfsolve.F: 700  format(1x,'Converged in 1 iteration (probably reference state)')
hfsolve.F: 9222 format(3x,'Orbital',4x,'Filling',7x,'Eigenvalues',4x,
hfsolve.F:      write(7,*) " !!ERROR!! Could not find self-consistent solution!"
hfsolve.F:      write(6,*) " !!ERROR!! Could not find self-consistent solution!"
hfsolve.F:     +     ' number of valence orbitals =',i3,/,
hfsolve.F:      end
hfuncs.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
hfuncs.F:c it under the terms of the GNU General Public License as published by
hfuncs.F:c the Free Software Foundation; either version 2 of the License, or
hfuncs.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
hfuncs.F:c GNU General Public License for more details.
hfuncs.F:c You should have received a copy of the GNU General Public License
hfuncs.F:      end
hfuncs.F:*       Returns the value of an unnormalized (nl) hydrogenic function
hfuncs.F:*   hwf stands for hydrogenic wavefunction, equations are in page 4 of 
hfuncs.F:7     format(51h forbidden combination of n and l in hwf subprogram/
hfuncs.F:      end
hfuncs.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfuncs.F:      den = li + lj + 1 + k12
hfuncs.F:      alpha= (1.d0/(li + 1) + 1.d0/(lj + 1))/(den + 1.d0)
hfuncs.F:      beta = (den+1.d0)*alpha**2 
hfuncs.F:     $     - 2.d0*(bi+bj+1.d0/((li+1)*(lj+1)))/(den+2.d0)
hfuncs.F:     $     *(((beta*zr+alpha)*zr+1.d0)/(den*h1)+0.5d0)
hfuncs.F:      end
hfuncs.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfuncs.F:      dimension yk(npdm)
hfuncs.F:      den = lo(i) + lo(j) + 3
hfuncs.F:      cd = 1.d0 + z*r(1)*(den-1.d0)/
hfuncs.F:     $     ((den+1.d0)*((lo(i)+1)*(lo(j)+1)))
hfuncs.F:      d = yk(1)*rnlp(1,i)*rnlp(1,j)*r(1)**kk*( cd/(den*h1)+ 0.5)
hfuncs.F:      enddo
hfuncs.F:      end
hfuncs.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfuncs.F:      dimension yk(npdm),yr(npdm),x(npdm)
hfuncs.F:      end
hfuncs.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfuncs.F:      dimension yr(npdm),x(npdm)
hfuncs.F:      enddo
hfuncs.F:      end
hfuncs.F:*       controls the calculation of off-diagonal energy parameters.
hfuncs.F:*   orthogonality requirement.   eq. (7-10) is used to calculate the
hfuncs.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfuncs.F:*  *****  rotate pairs connected by orthogonality but not when one of
hfuncs.F:            if (dabs(e(i,j)) .gt. 1.d-10) then
hfuncs.F:            endif
hfuncs.F:         enddo
hfuncs.F:      enddo
hfuncs.F:*  *****   compute off-diagonal energy parameters
hfuncs.F:            if (dabs(e(i,j)) .gt. 1.d-10) then
hfuncs.F:               if ( j .lt. 1) then
hfuncs.F:               else if (wnl(i) .eq. wnl(j)) then
hfuncs.F:                     if (ii.eq.i .or. ii.eq.j) then
hfuncs.F:                           if(ii.eq.i) then
hfuncs.F:                           else if (ii.eq.j) then
hfuncs.F:                           end if
hfuncs.F:                        enddo
hfuncs.F:                        enddo
hfuncs.F:                     end if
hfuncs.F:                  enddo
hfuncs.F:               end if
hfuncs.F:            end if
hfuncs.F:            if (dabs(e(i,j)) .gt. 1.d-10) then
hfuncs.F:            end if
hfuncs.F:         enddo
hfuncs.F:      enddo
hfuncs.F:      end
hfuncs.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfuncs.F:            if (e(i,j) .ne. 0.d0 ) then
hfuncs.F:               if (dabs(c) .gt. 1.d-10.or.ilast) then
hfuncs.F:                  enddo
hfuncs.F:               end if
hfuncs.F:            end if
hfuncs.F:         enddo
hfuncs.F:         if (change) then
hfuncs.F:            enddo
hfuncs.F: 67         if (dabs(rnlp(m,i)) .lt. 1.d-15) then
hfuncs.F:            end if
hfuncs.F:         end if
hfuncs.F:      enddo
hfuncs.F:      end
hfuncs.F:*        this routine analyses the energy expression to determine the
hfuncs.F:*   if the condition is zero, the off-diagonal energy parameters may
hfuncs.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfuncs.F:      if (qi .eq. 2.0*(2*lo(i)+1) .and. qj .eq. 2.0*(2*lo(j)+1)) then
hfuncs.F:      endif
hfuncs.F:      if (dabs(qi - qj) .lt. 1.d-14) then
hfuncs.F:      endif
hfuncs.F:         if (dabs(c) .lt. 1.d-8) then 
hfuncs.F:         endif
hfuncs.F:         if (dabs(cj) .lt. 1.d-8) then
hfuncs.F:         endif
hfuncs.F:         if (dabs(c) .ge. 1.d-8) then
hfuncs.F:         endif
hfuncs.F:         if (mf .eq. i .or. mf.eq. j) then
hfuncs.F:         endif
hfuncs.F:            if (dabs(c) .lt. 1.d-8) then
hfuncs.F:            endif
hfuncs.F:            if  (dabs(c) .lt. 1.d-8) then 
hfuncs.F:            endif
hfuncs.F:     $     le. 2.d-8 ) then 
hfuncs.F:      endif
hfuncs.F: 101  if (dabs(g)+dabs(dg) .gt. 1.d-8 .or. dabs(e(i,j)) .gt. 2.d-5) then
hfuncs.F:         enddo
hfuncs.F:      end if
hfuncs.F:      end
hfuncs.F:      dimension yk(npdm)
hfuncs.F:      end
hfuncs.F:      dimension yk(npdm)
hfuncs.F:      end
hfuncs.F:      dimension yk(npdm)
hfuncs.F:      end
hfuncs.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hfuncs.F:      end
hrtree.F:c it under the terms of the GNU General Public License as published by
hrtree.F:c the Free Software Foundation; either version 2 of the License, or
hrtree.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
hrtree.F:c GNU General Public License for more details.
hrtree.F:c You should have received a copy of the GNU General Public License
hrtree.F:c compute hartree term of scf potential from charge dens. q
hrtree.F:c this version improves implementation of trap. rule corrections, using
hrtree.F:c exp(y) (makes r a logarithmic grid); r = r(y); q = charge dens on same
hrtree.F:      dimension q(npdm),r(npdm),rvh(npdm)
hrtree.F:c    $' density integral.',/,1x,'(.5*decay)**2 =',e20.7,
hrtree.F:      end
hysolve.F:c it under the terms of the GNU General Public License as published by
hysolve.F:c the Free Software Foundation; either version 2 of the License, or
hysolve.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
hysolve.F:c GNU General Public License for more details.
hysolve.F:c You should have received a copy of the GNU General Public License
hysolve.F:c     determine the self-consistent solution
hysolve.F:c     External (shared between C and Fortran) common blocks
hysolve.F:      common /filenames/ file_log
hysolve.F:      common /box/ iboxstart(n0),iboxend(n0),boxheight(n0),numbox
hysolve.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
hysolve.F:      dimension rvn(npdm),rvf(npdm),eold(n0),p(npdm)
hysolve.F:      dimension rsatom(npdm),f(npdm),f2(npdm),f3(npdm)
hysolve.F:      dimension pder(npdm),ader(npdm)
hysolve.F:      dimension dl(n0), rsatom2(npdm)
hysolve.F:      dimension rsold(npdm),wnlfract(npdm)
hysolve.F:      dimension wavea(npdm),icarray(n0)
hysolve.F:      open(unit=7,file=file_log,form='formatted',access='append')
hysolve.F:c     User supplied eigenvalue guesses were never used in the SRL
hysolve.F:      if (irel.eq.1) then
hysolve.F:            en(i)=-z*z/(no(i)*no(i))
hysolve.F:         enddo
hysolve.F:            if (ibd(i).ne.0) en(ii)=-z*z/(no(ii)*no(ii))
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:c      if (ipsp.eq.1) then
hysolve.F:c            write(7,*) i,en(i),no(i),lo(i),so(i),ibd(i)
hysolve.F:c         enddo
hysolve.F:c      endif
hysolve.F:      write(7,*) '---------Eigenvalue guesses---------'      
hysolve.F:         write(7,9339) no(i),xc(lo(i)),en(i)
hysolve.F:      enddo
hysolve.F:      if (ipsp.eq.1) then
hysolve.F:      endif
hysolve.F:      if (inl.ne.0) then
hysolve.F:            enddo
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:      if (ifc.eq.0) then
hysolve.F:            eold(j) = en(j)
hysolve.F:            if (irel.eq.0) then
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            endif               
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:      if (inl.ne.0) then
hysolve.F:          enddo
hysolve.F:        enddo
hysolve.F:      endif
hysolve.F:      enddo
hysolve.F:      !open(unit=7,file=file_log,form='formatted',access='append')
hysolve.F:      iflag=0  ! comment by JY: this is a dummy variable 
hysolve.F:c     EJW - adding this to keep allow to pick a hyrdogenic wavefunction 
hysolve.F:      enddo
hysolve.F:         en(i)=-en(i)
hysolve.F:         enddo
hysolve.F:         e(i,i)=en(i)
hysolve.F:         enddo
hysolve.F:      enddo
hysolve.F:      if (ipsp.eq.0) then
hysolve.F:            enddo
hysolve.F:            e(j,j)=-en(j)
hysolve.F:            enddo
hysolve.F:         enddo
hysolve.F:            enddo
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:      enddo
hysolve.F:      enddo
hysolve.F:      if (ipsp.eq.0) then
hysolve.F:            enddo
hysolve.F:         enddo
hysolve.F:            if (lcount(lo(i)+1).gt.1) then
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:            if (e(i,j).gt.0.d0) then
hysolve.F:               if (abs(rx).gt.1e-8) then
hysolve.F:                  enddo
hysolve.F:               endif
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      enddo
hysolve.F:      !end initialization of HF
hysolve.F:      if (inl.ne.0) then
hysolve.F:        write(7,*)"Performing non-local pseudopotential calculation"
hysolve.F:         if (ipsp.ne.0) then
hysolve.F:       write(7,*) "Performing semi-local pseudopotential calculation"
hysolve.F:         endif
hysolve.F:      endif
hysolve.F:      if (ipsp.eq.1.and.inl.ne.0) then
hysolve.F:      endif
hysolve.F: 9600 format(1x,'Using the ',a1,' potential as the local potential')
hysolve.F:      if (ipsp.eq.1.and.inl.ne.0.and.numbox.gt.0) then
hysolve.F:         enddo
hysolve.F:            write(7,9240) i,r(iboxstart(i)),r(iboxend(i)),boxheight(i) 
hysolve.F:            if (r(iboxend(i)).gt.rindmin) ioutmin = 1
hysolve.F:            if (r(iboxend(i)).gt.rindmax) ioutmax = 1
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F: 9220 format(1x,'--Augmentation operator info--')
hysolve.F: 9250 format(1x,'NOTE: One or more functions extend beyond the',
hysolve.F: 9260 format(1x,'WARNING!: One or more functions extend beyond the',
hysolve.F:c     Begin self-consistency loop.
hysolve.F:         if (niter.eq.1) then
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:         enddo
hysolve.F:c     Section 3:  call schsl for each orbital & compile charge density.
hysolve.F:         if(ixc.ge.0. .and. ixc.lt.7) then
hysolve.F:            if (m.le.ncore) then
hysolve.F:            endif
hysolve.F:            if (ifc.eq.0.or.m.gt.ncore) then
hysolve.F:c     if not a frozen core calc or if valence
hysolve.F:               if (irel.eq.0) then
hysolve.F:                  if (inl.ne.0) then
hysolve.F:                     enddo
hysolve.F:                     call schsl (m,no(m),lo(m),en(m),nmax(m),
hysolve.F:                     enddo
hysolve.F:                     call schsl(m,no(m),lo(m),en(m),nmax(m),
hysolve.F:                  endif
hysolve.F:                  enddo
hysolve.F:                  enddo                  
hysolve.F:                  edif = abs((en(m) - eold(m))/eold(m))
hysolve.F:                  eold(m) = en(m)
hysolve.F:     $                 rnlb(1,m),z,rvcoul,en,nmax(m),ibound)
hysolve.F:                  enddo
hysolve.F:                  enddo                  
hysolve.F:                  edif = abs((en(m) - eold(m))/eold(m))
hysolve.F:                  eold(m) = en(m)
hysolve.F:               endif
hysolve.F:c     if not a frozen core calc or if valence 
hysolve.F:            endif
hysolve.F:          enddo
hysolve.F:          endif
hysolve.F:          !LZT: end application of kohn-sham operator
hysolve.F:          if(ixc.lt.0 .or. ixc.eq.7) then
hysolve.F:            write (7,*) "Hybrid functionals will be implemented soon!"
hysolve.F:          endif
hysolve.F:          if (ixc.eq.7) then 
hysolve.F:          endif
hysolve.F:         if(maxim.eq.0) then
hysolve.F:         endif
hysolve.F:c     Section 4:  mix density
hysolve.F:         if (niter.gt.3) then
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:c     Section 5:  update self-consistent potentials and compute energy.
hysolve.F:         if (rpcc.gt.1e-12.and.ipsp.ne.0) then
hysolve.F:            enddo
hysolve.F:            enddo
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:            ebs = ebs + wnl(m) * en(m)
hysolve.F:         enddo
hysolve.F:c     Section 6:  Mix potentials
hysolve.F:         enddo
hysolve.F:         enddo
hysolve.F:            enddo
hysolve.F:         enddo
hysolve.F:         if (niter.eq.1) then
hysolve.F:         endif
hysolve.F:c     Section 7:  predict trial eigenvals use 1st order perturb theory.
hysolve.F:         enddo
hysolve.F:            if (m.le.ncore) then
hysolve.F:            endif
hysolve.F:            if (ifc.eq.0.and.ibound.eq.1) then
hysolve.F:               if (irel.eq.0) then
hysolve.F:                  enddo
hysolve.F:                  enddo
hysolve.F:               endif
hysolve.F:               if(nmax(m).le.10) then
hysolve.F:               endif
hysolve.F:               en(m) = en(m) + xl
hysolve.F:               if (en(m).ge.0.0) then
hysolve.F:                  enddo
hysolve.F:                  en(m) = vmin * 0.5d0
hysolve.F:                  write (7,505) nlm(m),en(m)               
hysolve.F:                  if (en(m).ne.en(m)) then
hysolve.F:                  endif
hysolve.F:               endif
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      enddo !self-consistency loop ends here
hysolve.F: 505  format(1x,'!WARNING! positive eigenvalue predicted',
hysolve.F:      if (ilogder.eq.1) then
hysolve.F:         if (ipsp.eq.0) then
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:         if (ipsp.eq.1) then
hysolve.F:            if (inl.eq.0) then
hysolve.F:                  enddo
hysolve.F:                  enddo
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         endif
hysolve.F:      endif
hysolve.F:         if (irel.eq.0) then
hysolve.F:               if (abs(rnl(k,i)).gt.1e-10) then
hysolve.F:                  if (rnl(k,i).lt.0.0) then
hysolve.F:                     enddo
hysolve.F:                  endif
hysolve.F:               endif
hysolve.F:            enddo
hysolve.F:c            if (ibd(i-ncore).eq.0) then
hysolve.F:c               enddo
hysolve.F:c            endif
hysolve.F:               if (abs(rnla(k,i)).gt.1e-10) then
hysolve.F:                  if (rnla(k,i).lt.0.0) then
hysolve.F:                     enddo
hysolve.F:                  endif
hysolve.F:               endif
hysolve.F:            enddo
hysolve.F:               if (abs(rnlb(k,i)).gt.1e-10) then
hysolve.F:                  if (rnlb(k,i).lt.0.0) then
hysolve.F:                     enddo
hysolve.F:                  endif
hysolve.F:               endif
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:      enddo
hysolve.F:c     compute valence density 
hysolve.F:      enddo
hysolve.F:         if (irel.eq.0) then
hysolve.F:            enddo
hysolve.F:            enddo
hysolve.F:         endif
hysolve.F:      enddo
hysolve.F:c     compute core density
hysolve.F:      if (ipsp.eq.0) then
hysolve.F:         enddo
hysolve.F:            if (irel.eq.0) then
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:c     loop over valence
hysolve.F:      if (irel.eq.0) then
hysolve.F:            enddo
hysolve.F:            if (ibd(ic).eq.1) then
hysolve.F:c     special treatment for unbound states (norm from 0 to rc is 1)
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo                     
hysolve.F:            enddo
hysolve.F:            if (ibd(ic).eq.1) then
hysolve.F:               enddo
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:c      if (ipsp.eq.0) then
hysolve.F:c            enddo
hysolve.F:c         enddo
hysolve.F:c      endif
hysolve.F:c        if (rnla(maxim,i).lt.0.0) then
hysolve.F:c          enddo
hysolve.F:c        endif
hysolve.F:c      enddo
hysolve.F:      if (irel.eq.0) then
hysolve.F:            if (ibd(ic).ne.0) then
hysolve.F:                  if (rnl(j,i).lt.rnl(j+1,i)) then
hysolve.F:                  endif
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:            if (ibd(i-ncore).ne.0) then
hysolve.F:                  if (rnla(j,i).lt.rnla(j+1,i)) then
hysolve.F:     $                    and.(abs(rnla(j,i)).gt.1e-6)) then
hysolve.F:                     endif
hysolve.F:                  endif
hysolve.F:               enddo
hysolve.F:            endif
hysolve.F:         enddo
hysolve.F:      endif
hysolve.F:      if (niter.eq.1) then
hysolve.F:      endif
hysolve.F:         if (irel.eq.0) then
hysolve.F:            write (7,9223) nlm(i),wnl(i),en(i)
hysolve.F:            if (lo(i).eq.0) then
hysolve.F:               write (7,9523) nlm(i),wnl(i),en(i)
hysolve.F:               if (so(i).lt.0) then
hysolve.F:                  write (7,9323) nlm(i),wnl(i),en(i)
hysolve.F:                  write (7,9423) nlm(i),wnl(i),en(i)
hysolve.F:               endif
hysolve.F:            endif
hysolve.F:         endif
hysolve.F:      enddo
hysolve.F:         if (irel.eq.0) then
hysolve.F:            if (ibd(ic).ne.0) then
hysolve.F:               write (7,9223) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
hysolve.F:               write (7,9224) nlm(i),wnl(i),en(i)
hysolve.F:            endif
hysolve.F:            if (lo(i).eq.0) then
hysolve.F:               if (ibd(ic).ne.0) then
hysolve.F:                  write (7,9523) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
hysolve.F:                  write (7,9524) nlm(i),wnl(i),en(i)
hysolve.F:               endif
hysolve.F:               if (so(i).lt.0) then
hysolve.F:                  if (ibd(ic).ne.0) then
hysolve.F:                     write (7,9323) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
hysolve.F:                     write (7,9324) nlm(i),wnl(i),en(i)
hysolve.F:                  endif
hysolve.F:                  if (ibd(ic).ne.0) then
hysolve.F:                     write (7,9423) nlm(i),wnl(i),en(i),rnorm(i),rvap(i)
hysolve.F:                     write (7,9424) nlm(i),wnl(i),en(i)
hysolve.F:                  endif
hysolve.F:               endif
hysolve.F:            endif
hysolve.F:         endif
hysolve.F:      enddo
hysolve.F:      if (ipsp.ne.0.and.rpcc.gt.1e-12) then
hysolve.F:      endif
hysolve.F: 700  format(1x,'Converged in 1 iteration (probably reference state)')
hysolve.F: 9222 format(3x,'Orbital',4x,'Filling',7x,'Eigenvalues',4x,
hysolve.F:      if (inl.ne.0) then
hysolve.F:      endif
hysolve.F:      write(7,*) " !!ERROR!! Could not find self-consistent solution!"
hysolve.F:     +     ' number of valence orbitals =',i3,/,
hysolve.F:      end
intdir.F:c it under the terms of the GNU General Public License as published by
intdir.F:c the Free Software Foundation; either version 2 of the License, or
intdir.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
intdir.F:c GNU General Public License for more details.
intdir.F:c You should have received a copy of the GNU General Public License
intdir.F:      subroutine intdir(gg,gp,ag,ap,ggmat,gpmat,en,dv,av,
intdir.F:c            solution of the inhomogenios dirac equation                        
intdir.F:c ag and ap development coefficients of  gg and gp                              
intdir.F:c en one-electron energy                                                        
intdir.F:c fl power of the first development term at the origin                          
intdir.F:c agi (api) initial values of the first development coefficients                
intdir.F:c at the origin of a large (small) component                                    
intdir.F:c ainf initial value for large component at point dr(max0)                      
intdir.F:c   - at the end of tabulation of gg gp                                         
intdir.F:      dimension gg(npdm),gp(npdm),ag(10),ap(10),
intdir.F:      dimension dv(npdm)
intdir.F:      if (icall.eq.0) then                                                      
intdir.F:      endif                                                                     
intdir.F:      ec=en/cl                                                                  
intdir.F:c      enddo
intdir.F:      if (mat.ge.imax) then    
intdir.F:c     i had trouble with screened k-hole for la, for f-electrons.                 
intdir.F:c     below i still define matching point if one electron energy is               
intdir.F:         if (ec .gt. -0.0003) then                                           
intdir.F:         endif                                                               
intdir.F:      endif   
intdir.F:c     integration of the inhomogenious system                                   
intdir.F:         if ((imax+1).le.(mat+npi)) then                                        
intdir.F:         endif                                                                  
intdir.F:c      write(7,*) 'end test1', test1
intdir.F:      end                                                                       
interp2.F:c it under the terms of the GNU General Public License as published by
interp2.F:c the Free Software Foundation; either version 2 of the License, or
interp2.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
interp2.F:c GNU General Public License for more details.
interp2.F:c You should have received a copy of the GNU General Public License
interp2.F:      dimension f(npdm),f2(npdm),fp(npdm),f3(npdm)
interp2.F:      enddo
interp2.F:      end
interp2.F:c     Given arrays x(1:n) and y(1:n) containing a tabulated function,
interp2.F:c     i.e., yi = f(xi), with x1 < x2 < .. . < xN, and given values yp1
interp2.F:c     y2(1:n) of length n which contains the second derivatives of the
interp2.F:      if (yp1.gt..99e30) then 
interp2.F:      endif
interp2.F:      enddo 
interp2.F:      if (ypn.gt..99e30) then 
interp2.F:      endif
interp2.F:      enddo 
interp2.F: 1    if (khi-klo.gt.1) then
interp2.F:         if (xa(k).gt.x)then
interp2.F:         endif
interp2.F:      endif 
lagdat.F:c it under the terms of the GNU General Public License as published by
lagdat.F:c the Free Software Foundation; either version 2 of the License, or
lagdat.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
lagdat.F:c GNU General Public License for more details.
lagdat.F:c You should have received a copy of the GNU General Public License
lagdat.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
lagdat.F:      dimension kap(n0)
lagdat.F:      dimension ni(2),nj(2)                                                     
lagdat.F:      end                                                                       
logder.F:c it under the terms of the GNU General Public License as published by
logder.F:c the Free Software Foundation; either version 2 of the License, or
logder.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
logder.F:c GNU General Public License for more details.
logder.F:c You should have received a copy of the GNU General Public License
logder.F:      subroutine logder(en,z,l,isoft,rv,g,r,np,h,rlog,dl,nnt1,nr,p,
logder.F:      dimension rv(npdm),r(npdm),dl(n0),p(npdm),dld(npdm),g(npdm)
logder.F:      dimension w(4),wi(4)
logder.F:c     ensure nr is multiple of 2 integer and nr >= 4
logder.F:c     ensure that rlog is within range of grid
logder.F:      if(rlog.ge.r(np-nrh-1)) then
logder.F:      endif
logder.F:      e = en
logder.F:   94 e = en + float(ie-3)*de
logder.F:c       addition of inhomogeneous term g(i)
logder.F:c       local potential was taken as x*r**-1 + y + w*r
logder.F:c       non-local potential was taken as g1*r**(l+2.5)+g2*r**(l+3.5)+
logder.F:c     a = 1 (assumption of wavefunction leading term coefficient for
logder.F:c            inhomogeneous solution only)
logder.F:      enddo
logder.F:      if(ncross.ge.0) then
logder.F:      endif
logder.F:      enddo
logder.F:      enddo
logder.F:c     end of changes made by njr
logder.F:      enddo
logder.F:      if(ie.eq.3) then
logder.F:        enddo
logder.F:      endif
logder.F:      enddo
logder.F:c     energy derivative evaluated by 5-pt symmetric interpolation
logder.F:      end
nllogd.F:c it under the terms of the GNU General Public License as published by
nllogd.F:c the Free Software Foundation; either version 2 of the License, or
nllogd.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
nllogd.F:c GNU General Public License for more details.
nllogd.F:c You should have received a copy of the GNU General Public License
nllogd.F:c     External (shared between C and Fortran) common blocks
nllogd.F:      common /box/ iboxstart(n0),iboxend(n0),boxheight(n0),numbox
nllogd.F:      dimension rvloc(npdm),g(npdm)
nllogd.F:      dimension ader(npdm),phomder(npdm),pinhomdr(npdm),Flphider(npdm)
nllogd.F:      dimension Flwder(npdm),Flxder(npdm),pder(npdm)
nllogd.F:      dimension dl(n0)
nllogd.F:      enddo
nllogd.F:      enddo
nllogd.F:      if (ilogder.eq.1) then
nllogd.F:         if (rphas.gt.rcall(istate)) then
nllogd.F:            enddo
nllogd.F:               enddo
nllogd.F:               if (abs(flinvder).le.1e-10) then
nllogd.F:               endif
nllogd.F:               if (inl.eq.0) then wtilder = 0
nllogd.F:               enddo
nllogd.F:            enddo
nllogd.F:         endif
nllogd.F:      endif
nllogd.F:      end
nllogd.F:c     External (shared between C and Fortran) common blocks
nllogd.F:      common /box/ iboxstart(n0),iboxend(n0),boxheight(n0),numbox
nllogd.F:      dimension rvl(npdm),rvs(npdm)
nllogd.F:c      IB     = iboxend(1)
nllogd.F:c      ID     = iboxend(2)
nllogd.F:c      IG     = iboxend(3)
nllogd.F:c      IJ     = iboxend(4)
nllogd.F:      enddo
nllogd.F:c      enddo
nllogd.F:c      enddo
nllogd.F:c      enddo
nllogd.F:c      enddo
nllogd.F:c     Replacement for the blocks commented out above; allows for more
nllogd.F:         do j = iboxstart(i),iboxend(i)
nllogd.F:         enddo
nllogd.F:      enddo
nllogd.F:      end
norm.F:c it under the terms of the GNU General Public License as published by
norm.F:c the Free Software Foundation; either version 2 of the License, or
norm.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
norm.F:c GNU General Public License for more details.
norm.F:c You should have received a copy of the GNU General Public License
norm.F:      dimension hp(npdm),dr(npdm),gg(npdm),
norm.F:      end                                                                       
ortdat.F:c it under the terms of the GNU General Public License as published by
ortdat.F:c the Free Software Foundation; either version 2 of the License, or
ortdat.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
ortdat.F:c GNU General Public License for more details.
ortdat.F:c You should have received a copy of the GNU General Public License
ortdat.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
ortdat.F:      dimension kap(n0)
ortdat.F:      end                                                                       
pbe.F:C  pw91 CORRELATION, modified by K. Burke to put all arguments 
pbe.F:c  as variables in calling statement, rather than in common block
pbe.F:c inputs: up=up density
pbe.F:c       : lpot=flag to do potential(=0=>don't)
pbe.F:c outputs: exlsd=LSD exchange energy density, so that
pbe.F:c        : vxuplsd=up LSD exchange potential
pbe.F:c        : vxdnlsd=down LSD exchange potential
pbe.F:c        : exclsd=LSD exchange-correlation energy density
pbe.F:c        : vxcuplsd=up LSD exchange-correlation potential
pbe.F:c        : vxcdnlsd=down LSD exchange-correlation potential
pbe.F:c s=dimensionless density gradient=|grad rho|/ (2*fk*rho)_(rho=2*up)
pbe.F:      if(rho2.gt.1d-18)then
pbe.F:      endif
pbe.F:      if(rho2.gt.1d-18)then
pbe.F:      endif
pbe.F:c construct total density and contribution to ex
pbe.F:c sk=Ks=Thomas-Fermi screening wavevector=sqrt(4fk/pi)
pbe.F:c t=correlation dimensionless gradient=|grad rho|/(2*Ks*phi*rho)
pbe.F:c ec=lsd correlation energy
pbe.F:c vcup=lsd up correlation potential
pbe.F:c vcdn=lsd down correlation potential
pbe.F:c h=gradient correction to correlation energy
pbe.F:c dvcup=gradient correction to up correlation potential
pbe.F:c dvcdn=gradient correction to down correlation potential
pbe.F:      end
pbe.F:c  input lgga:  (=0=>don't put in gradient corrections, just LDA)
pbe.F:c  input lpot:  (=0=>don't get potential and don't need U and V)
pbe.F:c References:
pbe.F:c construct LDA exchange energy density
pbe.F:      if(lgga.eq.0)then
pbe.F:      endif
pbe.F:c construct PBE enhancement factor
pbe.F:c calculate potential from [b](24) 
pbe.F:c  input lgga:  (=0=>don't put in gradient corrections, just LDA)
pbe.F:c  input lpot:  (=0=>don't get potential and don't need U and V)
pbe.F:c References:
pbe.F:c construct LDA exchange energy density
pbe.F:      if(lgga.eq.0)then
pbe.F:      endif
pbe.F:c construct PBE enhancement factor
pbe.F:c calculate potential from [b](24) 
pbe.F:c       :  UU,VV,WW, only needed for PBE potential
pbe.F:c       : lpot=flag to do potential (0=>energy only)
pbe.F:c  output: ec=lsd correlation energy from [a]
pbe.F:c        : vcup=lsd up correlation potential
pbe.F:c        : vcdn=lsd dn correlation potential
pbe.F:c References:
pbe.F:c     {\sl Generalized gradient approximation made simple}, sub.
pbe.F:c     construction of a generalized gradient approximation:  The PW91
pbe.F:c     density functional}, submitted to Phys. Rev. B, Feb. 1996.
pbe.F:c numbers for use in LSD energy spin-interpolation formula, [c](9).
pbe.F:c      bet=coefficient in gradient expansion for correlation, [a](4).
pbe.F:c find LSD energy contributions, using [c](10) and Table I[c].
pbe.F:c EU=unpolarized LSD correlation energy
pbe.F:c EP=fully polarized LSD correlation energy
pbe.F:c LSD potential from [c](A1)
pbe.F:c PBE correlation energy
pbe.F:c G=phi(zeta), given after [a](3)
pbe.F:C ENERGY DONE. NOW THE POTENTIAL, using appendix E of [b].
pbe.F:c       :  UU,VV,WW, only needed for PBE potential
pbe.F:c       : lpot=flag to do potential (0=>energy only)
pbe.F:c  output: ec=lsd correlation energy from [a]
pbe.F:c        : vcup=lsd up correlation potential
pbe.F:c        : vcdn=lsd dn correlation potential
pbe.F:c References:
pbe.F:c     {\sl Generalized gradient approximation made simple}, sub.
pbe.F:c     construction of a generalized gradient approximation:  The PW91
pbe.F:c     density functional}, submitted to Phys. Rev. B, Feb. 1996.
pbe.F:c numbers for use in LSD energy spin-interpolation formula, [c](9).
pbe.F:c      bet=coefficient in gradient expansion for correlation, [a](4).
pbe.F:c find LSD energy contributions, using [c](10) and Table I[c].
pbe.F:c EU=unpolarized LSD correlation energy
pbe.F:c EP=fully polarized LSD correlation energy
pbe.F:c LSD potential from [c](A1)
pbe.F:c PBE correlation energy
pbe.F:c G=phi(zeta), given after [a](3)
pbe.F:C ENERGY DONE. NOW THE POTENTIAL, using appendix E of [b].
pbe.F:c LSD correlation energy, as given by (10) of
pbe.F:c    This piece delivers all of the Wu-Cohen functional ingredients
pbe.F:c  input lgga:  (=0=>don't put in gradient corrections, just LDA)
pbe.F:c  input lpot:  (=0=>don't get potential and don't need U and V)
pbe.F:c References:
pbe.F:c construct LDA exchange energy density
pbe.F:      if(lgga.eq.0)then
pbe.F:      endif
pbe.F:c construct PBE enhancement factor
pbe.F:c calculate potential from [b](24) 
potl.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
potl.F:c it under the terms of the GNU General Public License as published by
potl.F:c the Free Software Foundation; either version 2 of the License, or
potl.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
potl.F:c GNU General Public License for more details.
potl.F:c You should have received a copy of the GNU General Public License
potl.F:c     get the hartree potential function
potl.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
potl.F:      dimension yk(npdm),yr(npdm)
potl.F:      enddo
potl.F:            if (dabs(aaa(i,j,k)) .ge. 1.d-8) then
potl.F:               enddo
potl.F:            endif
potl.F:         enddo
potl.F:      enddo
potl.F:      end
potrdf.F:c it under the terms of the GNU General Public License as published by
potrdf.F:c the Free Software Foundation; either version 2 of the License, or
potrdf.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
potrdf.F:c GNU General Public License for more details.
potrdf.F:c You should have received a copy of the GNU General Public License
potrdf.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
potrdf.F:      dimension bgj(10),bpj(10),rjunk(npdm)                                                 
potrdf.F:      dimension at(npdm),bt(npdm),kap(n0)
potrdf.F:      dimension rvs(npdm),rvn(npdm),anoy(10)
potrdf.F:      enddo
potrdf.F:c addition of nuclear potential and division of potentials and                  
potrdf.F:c       their development limits by speed of light                              
potrdf.F:         if (abs(cg(i,ia)).gt.1e-15) then
potrdf.F:         endif
potrdf.F:c         enddo
potrdf.F:c     $        -en(ia)*cg(i,ia),-0.5*ttpsi,cg(i,ia)*kap(ia)
potrdf.F:      end                                                                       
potrdf2.F:c it under the terms of the GNU General Public License as published by
potrdf2.F:c the Free Software Foundation; either version 2 of the License, or
potrdf2.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
potrdf2.F:c GNU General Public License for more details.
potrdf2.F:c You should have received a copy of the GNU General Public License
potrdf2.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
potrdf2.F:      dimension bgj(10),bpj(10),rjunk(npdm)                                                 
potrdf2.F:      dimension at(npdm),bt(npdm),kap(n0)
potrdf2.F:      dimension rvs(npdm),rvn(npdm),anoy(10)
potrdf2.F:      dimension cg(npdm,n0),cp(npdm,n0),xgg(npdm),yrr(npdm)
potrdf2.F:c addition of nuclear potential and division of potentials and                  
potrdf2.F:c     their development limits by speed of light                              
potrdf2.F:         if (abs(cg(i,ia)).gt.1e-10) then
potrdf2.F:         endif
potrdf2.F:c     enddo
potrdf2.F:c     $        -en(ia)*cg(i,ia)/2.d0-0.5*ttpsi+cg(i,ia)*kap(ia)
potrdf2.F:c     $        -en(ia)*cg(i,ia)
potrdf2.F:      if (ipsp.ne.0) then
potrdf2.F:            if (r(k).lt.0.1) then
potrdf2.F:            endif
potrdf2.F:         enddo
potrdf2.F:      endif
potrdf2.F:      end                                                                       
pratt.F:c it under the terms of the GNU General Public License as published by
pratt.F:c the Free Software Foundation; either version 2 of the License, or
pratt.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
pratt.F:c GNU General Public License for more details.
pratt.F:c You should have received a copy of the GNU General Public License
pratt.F:c pratt method applied to accelerate convergence of sc potential
pratt.F:c the value of pratt must lie between 0 and 0.5.
pratt.F:      end
radin.F:c it under the terms of the GNU General Public License as published by
radin.F:c the Free Software Foundation; either version 2 of the License, or
radin.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
radin.F:c GNU General Public License for more details.
radin.F:c You should have received a copy of the GNU General Public License
radin.F:      dimension r(npdm), f(npdm)
radin.F:c     check if there are enough grid points available      
radin.F:      if(np.lt.10) then
radin.F:      endif
radin.F:c     since this is on logarithmic grid increment the power of r by one      
radin.F:      enddo
radin.F:c     determine the endpoint corrections to fourth order      
radin.F:      endpt  = (23.75*(     s1       +f(np  )*(r(np  )**n))
radin.F:c     add end point correction and multiply with width of log. grid
radin.F:      p = (p + endpt) * h
radin.F:      end
schsl.F:c it under the terms of the GNU General Public License as published by
schsl.F:c the Free Software Foundation; either version 2 of the License, or
schsl.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
schsl.F:c GNU General Public License for more details.
schsl.F:c You should have received a copy of the GNU General Public License
schsl.F:c     External (shared between C and Fortran) common blocks
schsl.F:      dimension rv(npdm), p(npdm), phom(npdm)
schsl.F:      dimension pinhom(npdm),wnlfract(npdm)
schsl.F:      enddo
schsl.F:      if (ibound.eq.0) then
schsl.F:      endif
schsl.F:      if (iterm.eq.1) then
schsl.F:c         if (itermcount.gt.5.and.igh.eq.0) then 
schsl.F:c         endif
schsl.F:      endif
schsl.F:         if (bound.and.iclose.eq.0) then
schsl.F:            if (iskip.eq.1) then 
schsl.F:               if (iskipcount.eq.itmax) then 
schsl.F:               endif
schsl.F:            endif
schsl.F:         else if (.not.bound) then
schsl.F:         endif            
schsl.F:c         if (igh.eq.0.and.ipos(iorb).gt.4) then 
schsl.F:c         endif
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      enddo
schsl.F: 9000 format(1x,'!WARNING! : schsl found a positive eigenvalue.',
schsl.F: 9003 format(1x,'!WARNING! : schsl found a positive eigenvalue.',
schsl.F:      end
schsl.F:      dimension psvph(npdm),phvph(npdm),fs(npdm),
schsl.F:      enddo
schsl.F:      effnlden = 2 * lang + 2
schsl.F:      call radin (r, phvph, 0, np, h, effnlden)
schsl.F:      if (abs(effnlden).le.1e-10) then 
schsl.F:        eff=effnlnum/effnlden
schsl.F:            if (abs(pg(i)).gt.1e-10) then
schsl.F:            endif
schsl.F:         enddo
schsl.F:      endif
schsl.F:      end
schsl.F:      dimension wnlf(npdm),rv(npdm),v(npdm)
schsl.F:      enddo
schsl.F:      if (lang.ne.0) then
schsl.F:         enddo
schsl.F:         if (elim.ge.0.0) then
schsl.F:         endif
schsl.F:      endif
schsl.F:      end
schsl.F:      dimension rv(npdm),v(npdm),wnlf(npdm)
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      if (imat.le.2) then
schsl.F:c     if (ei.ge.-etol.or.ncross.gt.node) then
schsl.F:         if (ei.ge.-etol) then
schsl.F:         endif
schsl.F:      endif
schsl.F:      if (inl.ne.0) then
schsl.F:         enddo
schsl.F:         if (imat.lt.indmax) then
schsl.F:         endif
schsl.F:         if (imat.lt.IB) then
schsl.F:         endif
schsl.F:         if (imat.lt.ID) then
schsl.F:         endif
schsl.F:         if (imat.lt.IG) then
schsl.F:         endif
schsl.F:      endif
schsl.F:      end
schsl.F:      dimension a(npdm),phom(npdm),pinhom(npdm),rv(npdm)
schsl.F:      dimension dl(n0),dld(5),g(npdm),fs(npdm),pref(npdm)
schsl.F:      dimension flph(npdm),flw(npdm),flx(npdm),p(npdm)
schsl.F:      enddo
schsl.F:      if (inl.ne.0) then
schsl.F:         enddo
schsl.F:      endif
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      if (abs(flinv).le.1e-10) then
schsl.F:      endif
schsl.F:      if (inl.eq.0) then wt = 0
schsl.F:      enddo
schsl.F:      end
schsl.F:      dimension p(npdm)
schsl.F:      enddo
schsl.F:      if (ncross.ne.node) then
schsl.F:         if (ncross.lt.node) then
schsl.F:            if (ietoolo.gt.2.and.ei.ge.-etol) then
schsl.F:            endif
schsl.F:            if (ietoohi.gt.2.and.ei.lt.elim) then
schsl.F:            endif
schsl.F:         endif
schsl.F:      endif
schsl.F:      end
schsl.F:      dimension rv(npdm),p(npdm)
schsl.F:      dimension rho(npdm)
schsl.F:      dimension v(npdm),pinhom(npdm),xai(npdm),xci(npdm),xdi(npdm)
schsl.F:      dimension xli(npdm),phom(npdm),xah(npdm),xch(npdm)
schsl.F:      dimension xdh(npdm),xlh(npdm),g(npdm),fs(npdm)
schsl.F:      enddo
schsl.F:      if (iclose.eq.0) then
schsl.F:         enddo
schsl.F:      endif
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      enddo
schsl.F:      end
schslrel.F:c it under the terms of the GNU General Public License as published by
schslrel.F:c the Free Software Foundation; either version 2 of the License, or
schslrel.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
schslrel.F:c GNU General Public License for more details.
schslrel.F:c You should have received a copy of the GNU General Public License
schslrel.F:c     find eigenvalue ev and the major and minor
schslrel.F:c     components of the wavefunction, ar and br
schslrel.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
schslrel.F:      dimension v(nrmax),ar(nrmax),br(nrmax)
schslrel.F:      dimension 
schslrel.F:c     eigenvalue tolerance and max number of iterations
schslrel.F:c     integration coefficients
schslrel.F:c     these are used to bracket eigenvalue
schslrel.F:c     max step size for eigenvalue changes
schslrel.F:      enddo
schslrel.F:c            if (r(j) .gt. rwell) then
schslrel.F:c            end if
schslrel.F:c            if (r(j)*r(j)*(v(j)-ev(iorb)) .gt. 750) then
schslrel.F:            if (r(j)*r(j)*(v(j)/r(j)-ev(iorb)) .gt. log(tol)**2) then
schslrel.F:            end if
schslrel.F:            if (v(j)/r(j) .gt. ev(iorb)) then
schslrel.F:            end if
schslrel.F:c     end outward integration
schslrel.F:c     if incorrect number of nodes modify energy stepwise
schslrel.F:         if (nodes .gt. no(iorb)-lo(iorb)-1) then
schslrel.F:         else if (nodes .lt. no(iorb)-lo(iorb)-1) then
schslrel.F:         end if
schslrel.F:         if (ninf .eq. np) then
schslrel.F:         end if
schslrel.F:            if (ninf .lt. np) then
schslrel.F:            end if
schslrel.F:c     end inward integration
schslrel.F:         enddo
schslrel.F:c     modify eigenvalue ev
schslrel.F:         if (abs(dev) .gt. abs(devmax)) then
schslrel.F:         end if
schslrel.F:c     eigenpar not converged in itmax iterations
schslrel.F:      if (nodes .ne. no(iorb)-lo(iorb)-1) then
schslrel.F:         enddo
schslrel.F:      endif
schslrel.F:c         enddo
schslrel.F:c      end if
schslrel.F:c         if (nodes.gt.12) then
schslrel.F:c            write(7,*) 'Doing reset of this eigenvalue',ev(iorb)
schslrel.F:c            write(7,*) 'New value', en(iorb)
schslrel.F:c         endif
schslrel.F:      enddo
schslrel.F:c      enddo
schslrel.F:      enddo
schslrel.F:      end
setuphf.F:c it under the terms of the GNU General Public License as published by
setuphf.F:c the Free Software Foundation; either version 2 of the License, or
setuphf.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
setuphf.F:c GNU General Public License for more details.
setuphf.F:c You should have received a copy of the GNU General Public License
setuphf.F:c     determine the self-consistent solution
setuphf.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
setuphf.F:      dimension epss(npdm),ka(n0),scc(n0),anoy(10)
setuphf.F:      enddo
setuphf.F:            if (ka(j).eq.ka(i)) then
setuphf.F:            endif
setuphf.F:         enddo
setuphf.F:         if (ipsp.eq.0) en(i)=-z*z/(2.d0*no(i)*no(i))
setuphf.F:         if (ipsp.ne.0) en(i)=en(i)/2.d0
setuphf.F:      enddo
setuphf.F:      enddo
setuphf.F:      enddo
setuphf.F:            rvps(i,k)=(dentfa(r(i),zeff,ch)+rvcore(i,k)/(2.d0*r(i)))/cl
setuphf.F:         enddo
setuphf.F:      enddo
setuphf.F:      enddo
setuphf.F:      av(2)=av(2)+dentfa(r(1),zeff,ch)/cl
setuphf.F:         if (ka(j).ge.0) then
setuphf.F:         endif
setuphf.F:     $        (j,no(j),lo(j),en(j), fl(j),bg(1,j),bp(1,j),rvps(1,j), 
setuphf.F:c         write(7,'(4i5,4f10.6)') j,ka(j),no(j),lo(j),so(j),wnl(j),en(j)
setuphf.F:         enddo
setuphf.F:         enddo
setuphf.F:      enddo                        
setuphf.F:      end
soldir.F:c it under the terms of the GNU General Public License as published by
soldir.F:c the Free Software Foundation; either version 2 of the License, or
soldir.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
soldir.F:c GNU General Public License for more details.
soldir.F:c You should have received a copy of the GNU General Public License
soldir.F:      subroutine soldir(iorb,nqn,lang,en,fl,agi,api,dv,
soldir.F:c     External (shared between C and Fortran) common blocks
soldir.F:      dimension hg(npdm),hp(npdm)
soldir.F:      dimension dv(npdm),bg(npdm),bp(npdm)
soldir.F:      dimension agh(10),aph(10),bgh(10),bph(10)
soldir.F:      enav=1.0d 00                                                              
soldir.F:c      write(7,*) 'entered soldir',iex,method,agi,api
soldir.F:      if (emin .ge. 0.0) then                                                   
soldir.F:      endif                                                                     
soldir.F:      if (en.lt.emin) en=emin*0.9d 00                                           
soldir.F:      edep=en                                                                   
soldir.F:      en=edep                                                                   
soldir.F:      if ( abs((enav-en)/en).lt.1.0d-01) imm=1                                  
soldir.F:      enav=en                                                                   
soldir.F:c      write(7,*) 'entered soldir2',iex,method
soldir.F:c     integration of the inhomogenious system                                   
soldir.F:c         write(7,*) 'before first int test1=',en
soldir.F:      call intdir (gg,gp,ag,ap,ggmat,gpmat,en,dv,av,
soldir.F:c      write(7,*) 'after first int iex, test1=',en
soldir.F:c     match large component for the homogenios system(method=0)                 
soldir.F:c     integration of the homogenios system                                      
soldir.F:      call intdir (hg,hp,agh,aph,hgmat,hpmat,en,dv,av,
soldir.F:c     match the large component for inhomogenious system(method=1)              
soldir.F:      if (method.lt.2) then                                                     
soldir.F:      endif                                                                     
soldir.F:      if (method.ge.2) then                                                     
soldir.F:c        integration of the system derived from disagreement in energy          
soldir.F:         call intdir (bg,bp,bgh,bph,bgmat,bpmat,en,dv,av,
soldir.F:c        match both components for inhomogenious system (method=2)              
soldir.F:c        correction to the energy (method=2)                                    
soldir.F:      endif                                                                     
soldir.F:c     search for the maximum of the modulus of large component                  
soldir.F:      if (j.gt.mat .and. modmat.eq.0) then                                      
soldir.F:      endif                                                                     
soldir.F:c this case can happen due to bad starting point in scf procedure.              
soldir.F:c      write(7,*) 'nodes',nd,node,en
soldir.F: 251  esup=en                                                                   
soldir.F:      en=en*8.0d-01                                                             
soldir.F:      if ( abs(en).gt.test1) go to 285                                          
soldir.F:c    *zero energy                                                               
soldir.F: 261  einf=en     
soldir.F:c      write(7,*) 'eee',einf,en,esup,emin
soldir.F: 263  en=en*1.2d 00                                                             
soldir.F:      if (en.gt.emin) go to 285                                                 
soldir.F:c    *energy is lower than the minimum of apparent potential                    
soldir.F:c    *the upper and lower limits of energy are identical                        
soldir.F: 281  en=(einf+esup)/2.0d 00                                                    
soldir.F:c this case can happen due to bad starting point in scf procedure.              
soldir.F:      if (method.eq.1) then                                                     
soldir.F:c        correction to the energy (method=1)                                    
soldir.F:      endif                                                                     
soldir.F:      en=en+f                                                                   
soldir.F:      g= abs(f/(en-f))  
soldir.F:c      write(7,*) 'adj1',en
soldir.F: 371  if ((en.ge.0 .or. g.gt.2.0d-01) .or.                                      
soldir.F:     1 (abs(c).gt.test .and. (en.lt.esup.or.en.gt.einf))) then                  
soldir.F:c        try smaller step in enrgy under above conditions                       
soldir.F:         en=en-f                                                                
soldir.F:c         write(7,*) 'adjusted f',f,g,en
soldir.F:      endif                                                                     
soldir.F:c      write(7,*) 'after norm', b,en,ies
soldir.F:      if ( abs(c).gt.test)  then                                                
soldir.F:c     on the latest stage selfconsistent process.                               
soldir.F:c     just stopped trying to match lower component                              
soldir.F:c     lines below were commented out.  ala 11/18/94                             
soldir.F:      endif                                                                     
soldir.F:      end                                                                       
xch.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
xch.F:c it under the terms of the GNU General Public License as published by
xch.F:c the Free Software Foundation; either version 2 of the License, or
xch.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
xch.F:c GNU General Public License for more details.
xch.F:c You should have received a copy of the GNU General Public License
xch.F:c     get the hartree potential function
xch.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
xch.F:      dimension yk(npdm),yr(npdm),x(npdm)
xch.F:      dimension meth(10)
xch.F:      enddo
xch.F:         if (j .ne. i) then
xch.F:               if (dabs(bbb(i,j,k)) .ge. 1.d-10) then
xch.F:                      !if (ixc.eq.7) then
xch.F:                      !endif
xch.F:                  enddo
xch.F:               endif
xch.F:            enddo
xch.F:         endif
xch.F:      enddo
xch.F:      if (iopt.eq.2) then
xch.F:         enddo
xch.F:      endif
xch.F:      if (iopt.eq.3) then
xch.F:         enddo
xch.F:      endif
xch.F:      if (iopt.eq.3) then
xch.F:            if (dabs(c).gt.1.d-10.and.(j.ne.i)) then
xch.F:                  !if (ixc.eq.7) then
xch.F:                  !endif
xch.F:               enddo
xch.F:            endif
xch.F:         enddo
xch.F:      endif
xch.F:      end
ykf.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
ykf.F:c it under the terms of the GNU General Public License as published by
ykf.F:c the Free Software Foundation; either version 2 of the License, or
ykf.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
ykf.F:c GNU General Public License for more details.
ykf.F:c You should have received a copy of the GNU General Public License
ykf.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
ykf.F:      dimension yk(npdm)
ykf.F:      enddo
ykf.F:      end
yzkrdf.F:c it under the terms of the GNU General Public License as published by
yzkrdf.F:c the Free Software Foundation; either version 2 of the License, or
yzkrdf.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
yzkrdf.F:c GNU General Public License for more details.
yzkrdf.F:c You should have received a copy of the GNU General Public License
yzkrdf.F:c tabulated untill point dr(j), and its' devlopment coefficients                
yzkrdf.F:c at the origin  yk = cte * r**(k+1) - developement limit,                      
yzkrdf.F:c cte lies in ap(1) and development coefficients in ag.                         
yzkrdf.F:c      common/ratom1/xnel(N0),en(N0),scc(N0),scw(N0),sce(N0),                    
yzkrdf.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
yzkrdf.F:      dimension chg(10)                                                         
yzkrdf.F:      dimension bgi(10),bgj(10),bpi(10),bpj(10)                                 
yzkrdf.F:      dimension cg(npdm,n0),cp(npdm,n0)
yzkrdf.F:      end                                                                       
yzkteg.F:c it under the terms of the GNU General Public License as published by
yzkteg.F:c the Free Software Foundation; either version 2 of the License, or
yzkteg.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
yzkteg.F:c GNU General Public License for more details.
yzkteg.F:c You should have received a copy of the GNU General Public License
yzkteg.F:c dr tabulation points   h exponential step                                     
yzkteg.F:c idim dimension of the blocks f,g and dr                                       
yzkteg.F:c at the origin yk=cte*r**(k+1)-developement limit                              
yzkteg.F:c development coefficients at the origin in af and ag.                          
yzkteg.F:      dimension f(npdm),af(10),g(npdm),ag(10),dr(npdm)                             
yzkteg.F:c    initialisation and development coefficients of yk                          
yzkteg.F:         if (af(i).ne.0.0d 00) then                                             
yzkteg.F:         endif                                                                  
yzkteg.F:      end                                                                       
zkf.F:c Obtained from http://atoms.vuse.vanderbilt.edu/Elements/CompMeth/hf.f
zkf.F:c it under the terms of the GNU General Public License as published by
zkf.F:c the Free Software Foundation; either version 2 of the License, or
zkf.F:c but WITHOUT ANY WARRANTY; without even the implied warranty of
zkf.F:c GNU General Public License for more details.
zkf.F:c You should have received a copy of the GNU General Public License
zkf.F:      common /adat/ wnl(n0),en(n0),so(n0),xion
zkf.F:      dimension yk(npdm)
zkf.F:      enddo
zkf.F:      den=lo(i)+lo(j)+3+k
zkf.F:      fact = (1.d0/(lo(i)+1) + 1.d0/(lo(j)+1))/(den + 1.d0)
zkf.F:      !if (ixc.eq.7) then
zkf.F:      !endif
zkf.F:      yk(1) = f1*(1.d0 + z*r(1)*fact)/den
zkf.F:      yk(2) = f2*(1.d0 + z*r(2)*fact)/den
zkf.F:         !if (ixc.eq.7) then
zkf.F:         !endif
zkf.F:      enddo
zkf.F:      if (iabs(i-j)  +  iabs(k) .eq. 0) then
zkf.F:         enddo 
zkf.F:      endif
zkf.F:      enddo
zkf.F:      end
